------------------------------------
--Euraylib                        --
--Written by Andy P. (Icy_Viking) --
--Raylib version 3.5.0            --
--Euphoria version 4.1.0 beta 2   --
--Icy Viking Games                --
--Euphoria wrapper for Raylib     --
------------------------------------
without warning

include std/dll.e
include std/convert.e
include std/machine.e
include std/os.e

public atom ray

ifdef WINDOWS then
	ray = open_dll("raylib.dll")
	if ray = -1 then
		puts(1,"Failed to open raylib.dll!\n")
		abort(0)
	end if
	elsifdef LINUX or FREEBSD then
	ray = open_dll("raylib.so")
	if ray = -1 then
		puts(1,"Failed to open raylib!\n")
		abort(0)
	end if
	elsifdef OSX then
	ray = open_dll("raylib.dylib")
	if ray = -1 then
		puts(1,"Failed to open raylib!\n")
		abort(0)
	end if
end ifdef

include flags.e
--include raylibshim.e

procedure poke_float32(atom ptr, object val)

 if atom(val) then
 	val = (val)
 end if
 
	for i = 1 to length(val) do
		poke(ptr,atom_to_float32(val[i]))
		ptr += sizeof(C_FLOAT)
	end for
	
end procedure

--Core Module Functions
--Window Functions

public constant xInitWindow = define_c_proc(ray,"+InitWindow",{C_INT,C_INT,C_POINTER}),
				xWindowShouldClose = define_c_func(ray,"+WindowShouldClose",{},C_BOOL),
				xCloseWindow = define_c_proc(ray,"+CloseWindow",{}),
				xIsWindowReady = define_c_func(ray,"+IsWindowReady",{},C_BOOL),
				xIsWindowMinimized = define_c_func(ray,"+IsWindowMinimized",{},C_BOOL),
				xIsWindowResized = define_c_func(ray,"+IsWindowResized",{},C_BOOL),
				xIsWindowHidden = define_c_func(ray,"+IsWindowHidden",{},C_BOOL),
				xToggleFullscreen = define_c_proc(ray,"+ToggleFullscreen",{}),
				xUnhideWindow = define_c_proc(ray,"+UnhideWindow",{}),
				xHideWindow = define_c_proc(ray,"+HideWindow",{}),
				xSetWindowIcon = define_c_proc(ray,"+SetWindowIcon",{C_POINTER}),
				xSetWindowTitle = define_c_proc(ray,"+SetWindowTitle",{C_POINTER}),
				xSetWindowPosition = define_c_proc(ray,"+SetWindowPosition",{C_INT,C_INT}),
				xSetWindowMonitor = define_c_proc(ray,"+SetWindowMonitor",{C_INT}),
				xSetWindowMinSize = define_c_proc(ray,"+SetWindowMinSize",{C_INT,C_INT}),
				xSetWindowSize = define_c_proc(ray,"+SetWindowSize",{C_INT,C_INT}),
				xGetWindowHandle = define_c_func(ray,"+GetWindowHandle",{},C_POINTER),
				xGetScreenWidth = define_c_func(ray,"+GetScreenWidth",{},C_INT),
				xGetScreenHeight = define_c_func(ray,"+GetScreenHeight",{},C_INT),
				xGetMonitorCount = define_c_func(ray,"+GetMonitorCount",{},C_INT),
				xGetMonitorWidth = define_c_func(ray,"+GetMonitorWidth",{C_INT},C_INT),
				xGetMonitorHeight = define_c_func(ray,"+GetMonitorHeight",{C_INT},C_INT),
				xGetMonitorPhysicalWidth = define_c_func(ray,"+GetMonitorPhysicalWidth",{C_INT},C_INT),
				xGetMonitorPhysicalHeight = define_c_func(ray,"+GetMonitorPhysicalHeight",{C_INT},C_INT),
				xGetMonitorName = define_c_func(ray,"+GetMonitorName",{C_INT},C_POINTER),
				xGetClipboardText = define_c_func(ray,"+GetClipboardText",{},C_POINTER),
				xSetClipboardText = define_c_proc(ray,"+SetClipboardText",{C_POINTER}),
				xGetWindowPosition = define_c_func(ray,"+GetWindowPosition",{},C_FLOAT),
				xSetWindowState = define_c_proc(ray,"+SetWindowState",{C_UINT}),
				xIsWindowFocused = define_c_func(ray,"+IsWindowFocused",{},C_BOOL),
				xGetWindowScaleDPI = define_c_func(ray,"+GetWindowScaleDPI",{},C_FLOAT),
				xGetMonitorRefreshRate = define_c_func(ray,"+GetMonitorRefreshRate",{C_INT},C_INT),
				xClearWindowState = define_c_proc(ray,"+ClearWindowState",{C_UINT})
				
public procedure InitWindow(atom w,atom h,sequence title)

 atom str = allocate_string(title,1)
 c_proc(xInitWindow,{w,h,str})
	
end procedure

public function WindowShouldClose()

 return c_func(xWindowShouldClose,{})
	
end function

public procedure CloseWindow()

 c_proc(xCloseWindow,{})
	
end procedure

public function IsWindowReady()

 return c_func(xIsWindowReady,{})
	
end function

public function IsWindowMinimized()

 return c_func(xIsWindowMinimized,{})
	
end function

public function IsWindowResized()

 return c_func(xIsWindowResized,{})
	
end function

public function IsWindowHidden()

 return c_func(xIsWindowHidden,{})
	
end function

public procedure ToggleFullscreen()

 c_proc(xToggleFullscreen,{})
	
end procedure

public procedure UnhideWindow()

 c_proc(xUnhideWindow,{})
	
end procedure

public procedure HideWindow()

 c_proc(xHideWindow,{})
	
end procedure

public procedure SetWindowIcon(atom img)

 c_proc(xSetWindowIcon,{img})
	
end procedure

public procedure SetWindowTitle(sequence title)

 atom str = allocate_string(title,1)
 c_proc(xSetWindowTitle,{str})
	
end procedure

public procedure SetWindowPosition(atom x,atom y)

 c_proc(xSetWindowPosition,{x,y})
	
end procedure

public procedure SetWindowMonitor(atom mon)

 c_proc(xSetWindowMonitor,{mon})
	
end procedure

public procedure SetWindowMinSize(atom width,atom height)

 c_proc(xSetWindowMinSize,{width,height})
	
end procedure

public procedure SetWindowSize(atom w,atom h)

 c_proc(xSetWindowSize,{w,h})
	
end procedure

public function GetWindowHandle()

 return c_func(xGetWindowHandle,{})
	
end function

public function GetScreenWidth()

 return c_func(xGetScreenWidth,{})
	
end function

public function GetScreenHeight()

 return c_func(xGetScreenHeight,{})
	
end function

public function GetMonitorCount()

 return c_func(xGetMonitorCount,{})
	
end function

public function GetMonitorWidth(atom mon)

 return c_func(xGetMonitorWidth,{mon})
	
end function

public function GetMonitorHeight(atom mon)

 return c_func(xGetMonitorHeight,{mon})
	
end function

public function GetMonitorPhysicalWidth(atom mon)

 return c_func(xGetMonitorPhysicalWidth,{mon})
	
end function

public function GetMonitorPhysicalHeight(atom mon)

 return c_func(xGetMonitorPhysicalHeight,{mon})
	
end function

public function GetMonitorName(atom mon)

 return c_func(xGetMonitorName,{mon})
	
end function

public function GetClipboardText()

 return c_func(xGetClipboardText,{})
	
end function

public procedure SetClipboardText(sequence text)

 atom str = allocate_string(text,1)
 c_proc(xSetClipboardText,{str})
	
end procedure

public function GetWindowPosition()

 return c_func(xGetWindowPosition,{})
	
end function

public procedure SetWindowState(atom flags)

 c_proc(xSetWindowState,{flags})
	
end procedure

public function IsWindowFocused()

 return c_func(xIsWindowFocused,{})
	
end function

public function GetWindowScaleDPI()

 return c_func(xGetWindowScaleDPI,{})
	
end function

public function GetMonitorRefreshRate(atom mon)

 return c_func(xGetMonitorRefreshRate,{mon})
	
end function

public procedure ClearWindowState(atom flags)

 c_proc(xClearWindowState,{flags})
	
end procedure

--Cursor Functions

public constant xShowCursor = define_c_proc(ray,"+ShowCursor",{}),
				xHideCursor = define_c_proc(ray,"+HideCursor",{}),
				xIsCursorHidden = define_c_func(ray,"+IsCursorHidden",{},C_BOOL),
				xEnableCursor = define_c_proc(ray,"+EnableCursor",{}),
				xDisableCursor = define_c_proc(ray,"+DisableCursor",{}),
				xIsCursorOnScreen = define_c_func(ray,"+IsCursorOnScreen",{},C_BOOL)
				
public procedure ShowCursor()

 c_proc(xShowCursor,{})
	
end procedure

public procedure HideCursor()

 c_proc(xHideCursor,{})
	
end procedure

public function IsCursorHidden()

 return c_func(xIsCursorHidden,{})
	
end function

public procedure EnableCursor()

 c_proc(xEnableCursor,{})
	
end procedure

public procedure DisableCursor()

 c_proc(xDisableCursor,{})
	
end procedure

public function IsCursorOnScreen()

 return c_func(xIsCursorOnScreen,{})
	
end function

--Drawing Functions

public constant xClearBackground = define_c_proc(ray,"+ClearBackground",{C_UINT}),
				xBeginDrawing = define_c_proc(ray,"+BeginDrawing",{}),
				xEndDrawing = define_c_proc(ray,"+EndDrawing",{}),
				xBeginMode2D = define_c_proc(ray,"+BeginMode2D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT}),
				xEndMode2D = define_c_proc(ray,"+EndMode2D",{}),
				xBeginMode3D = define_c_proc(ray,"+BeginMode3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT}),
				xEndMode3D = define_c_proc(ray,"+EndMode3D",{}),
				xBeginTextureMode = define_c_proc(ray,"+BeginTextureMode",{C_POINTER}),
				xEndTextureMode = define_c_proc(ray,"+EndTextureMode",{})
				
public procedure ClearBackground(atom col)

 c_proc(xClearBackground,{col})
	
end procedure

public procedure BeginDrawing()

 c_proc(xBeginDrawing,{})
	
end procedure

public procedure EndDrawing()

 c_proc(xEndDrawing,{})
	
end procedure

public procedure BeginMode2D(atom ox,atom oy,atom tx,atom ty,atom rot,atom zoom)

 c_proc(xBeginMode2D,{ox,oy,tx,ty,rot,zoom})
	
end procedure

public procedure BeginMode3D(atom px,atom py,atom pz,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz,atom fov,integer mode)

 c_proc(xBeginMode3D,{px,py,pz,tx,ty,tz,ux,uy,uz,fov,mode})
	
end procedure

public procedure EndMode3D()

 c_proc(xEndMode3D,{})
	
end procedure

public procedure BeginTextureMode(atom tar)

 c_proc(xBeginTextureMode,{tar})
	
end procedure

public procedure EndTextureMode()

 c_proc(xEndTextureMode,{})
	
end procedure

--Screen-space Functions

public constant xGetMouseRay = define_c_func(ray,"+GetMouseRay",{C_FLOAT,C_FLOAT,C_POINTER},C_POINTER),
				xGetWorldToScreen = define_c_func(ray,"+GetWorldToScreen",{C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT),
				xGetCameraMatrix = define_c_func(ray,"+GetCameraMatrix",{C_POINTER},C_POINTER),
				xGetCameraMatrix2D = define_c_func(ray,"+GetCameraMatrix2D",{C_POINTER},C_POINTER),
				--xGetWorldToScreen = define_c_func(ray,"+GetWorldToScreen",{C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT),
				xGetWorldToScreenEx = define_c_func(ray,"+GetWorldToScreenEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER,C_INT,C_INT},C_FLOAT),
				xGetWorldToScreen2D = define_c_func(ray,"+GetWorldToScreen2D",{C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT),
				xGetScreenToWorld2D = define_c_func(ray,"+GetScreenToWorld2D",{C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT)
				
public function GetMouseRay(atom x,atom y,atom cam)

 return c_func(xGetMouseRay,{x,y,cam})
	
end function

public function GetWorldToScreen(atom x,atom y,atom z,atom cam)

 return c_func(xGetWorldToScreen,{x,y,z,cam})
	
end function

public function GetCameraMatrix(atom cam)

 return c_func(xGetCameraMatrix,{cam})
	
end function

public function GetCameraMatrix2D(atom cam)

 return c_func(xGetCameraMatrix2D,{cam})
	
end function

--public function GetWorldToScreen(atom x,atom y,atom z,atom cam)

 --c_proc(xGetWorldToScreen,{x,y,z,cam})
	
--end function

public function GetWorldToScreenEx(atom x,atom y,atom z,atom cam,atom w,atom h)

 return c_func(xGetWorldToScreenEx,{x,y,z,cam,w,h})
 
end function

public function GetWorldToScreen2D(atom x,atom y,atom cam)

 return c_func(xGetWorldToScreen2D,{x,y,cam})
	
end function

public function GetScreenToWorld2D(atom x,atom y,atom cam)

 return c_func(xGetScreenToWorld2D,{x,y,cam})
	
end function

--Time Functions

public constant xSetTargetFPS = define_c_proc(ray,"+SetTargetFPS",{C_INT}),
				xGetFPS = define_c_func(ray,"+GetFPS",{},C_INT),
				xGetFrameTime = define_c_func(ray,"+GetFrameTime",{},C_FLOAT),
				xGetTime = define_c_func(ray,"+GetTime",{},C_DOUBLE)
				
public procedure SetTargetFPS(atom fps)

 c_proc(xSetTargetFPS,{fps})
	
end procedure

public function GetFPS()

 return c_func(xGetFPS,{})
	
end function

public function GetFrameTime()

 return c_func(xGetFrameTime,{})
	
end function

public function GetTime()

 return c_func(xGetTime,{})
	
end function

--Color Functions

public constant xColorToInt = define_c_func(ray,"+ColorToInt",{C_UINT},C_INT),
				xColorNormalize = define_c_func(ray,"+ColorNormalize",{C_UINT},C_FLOAT),
				xColorToHSV = define_c_func(ray,"+ColorToHSV",{C_UINT},C_FLOAT),
				xColorFromHSV = define_c_func(ray,"+ColorFromHSV",{C_FLOAT},C_POINTER),
				xGetColor = define_c_func(ray,"+GetColor",{C_INT},C_POINTER),
				xFade = define_c_func(ray,"+Fade",{C_UINT,C_FLOAT},C_POINTER),
				xColorAlphaBlend = define_c_func(ray,"+ColorAlphaBlend",{C_UINT,C_UINT,C_UINT},C_UINT),
				xGetPixelColor = define_c_func(ray,"+GetPixelColor",{C_POINTER,C_INT},C_UINT),
				xSetPixelColor = define_c_proc(ray,"+SetPixelColor",{C_POINTER,C_UINT,C_INT})
				
public function ColorToInt(atom col)

 return c_func(xColorToInt,{col})
	
end function

public function ColorNormalize(atom col)

 return c_func(xColorNormalize,{col})
	
end function

public function ColorToHSV(atom col)

 return c_func(xColorToHSV,{col})
	
end function

public function ColorFromHSV(atom hsv)

 return c_func(xColorFromHSV,{hsv})
	
end function

public function GetColor(atom val)

 return c_func(xGetColor,{val})
	
end function

public function Fade(atom col,atom alpha)

 return c_func(xFade,{col,alpha})
	
end function

public function ColorAlphaBlend(atom dst,atom src,atom tint)

 return c_func(xColorAlphaBlend,{dst,src,tint})
	
end function

public function GetPixelColor(atom src,atom mat)

 return c_func(xGetPixelColor,{src,mat})
	
end function

public procedure SetPixelColor(atom dst,atom col,atom mat)

 c_proc(xSetPixelColor,{dst,col,mat})
	
end procedure

--Misc Functions

public constant xSetConfigFlags = define_c_proc(ray,"+SetConfigFlags",{C_UINT}),
				xSetTraceLogLevel = define_c_proc(ray,"+SetTraceLogLevel",{C_INT}),
				xSetTraceLogExit = define_c_proc(ray,"+SetTraceLogExit",{C_INT}),
				xSetTraceLogCallback = define_c_proc(ray,"+SetTraceLogCallback",{C_POINTER}),
				xTraceLog = define_c_proc(ray,"+TraceLog",{C_INT,C_POINTER}),
				xTakeScreenshot = define_c_proc(ray,"+TakeScreenshot",{C_POINTER}),
				xGetRandomValue = define_c_func(ray,"+GetRandomValue",{C_INT,C_INT},C_INT)
				
public procedure SetConfigFlags(sequence flags)

 c_proc(xSetConfigFlags,{flags})
	
end procedure

public procedure SetTraceLogLevel(atom xlog)

 c_proc(xSetTraceLogLevel,{xlog})
	
end procedure

public procedure SetTraceLogExit(atom xlog)

 c_proc(xSetTraceLogExit,{xlog})
	
end procedure

public procedure SetTraceLogCallback(atom cb)

 c_proc(xSetTraceLogCallback,{cb})
	
end procedure

public procedure TraceLog(atom xlog,sequence text)

 atom str = allocate_string(text,1)
 c_proc(xTraceLog,{xlog,str})
	
end procedure

public procedure TakeScreenshot(sequence file)

 atom str = allocate_string(file,1)
 c_proc(xTakeScreenshot,{str})
	
end procedure

public function GetRandomValue(atom min,atom max)

 return c_func(xGetRandomValue,{min,max})
	
end function

--

public constant xMemAlloc = define_c_func(ray,"+MemAlloc",{C_INT},C_POINTER),
				xMemFree = define_c_proc(ray,"+MemFree",{C_POINTER})
				
public function MemAlloc(atom size)

 return c_func(xMemAlloc,{size})
	
end function

public procedure MemFree(atom ptr)

 c_proc(xMemFree,{ptr})
	
end procedure

--File Management Functions

public constant xFileExists = define_c_func(ray,"+FileExists",{C_POINTER},C_BOOL),
				xIsFileExtension = define_c_func(ray,"+IsFileExtension",{C_POINTER,C_POINTER},C_BOOL),
				xGetExtension = define_c_func(ray,"+GetExtension",{C_POINTER},C_POINTER),
				xGetFileName = define_c_func(ray,"+GetFileName",{C_POINTER},C_POINTER),
				xGetFileNameWithoutExt = define_c_func(ray,"+GetFileNameWithoutExt",{C_POINTER},C_POINTER),
				xGetDirectoryPath = define_c_func(ray,"+GetDirectoryPath",{C_POINTER},C_POINTER),
				xGetWorkingDirectory = define_c_func(ray,"+GetWorkingDirectory",{},C_POINTER),
				xGetDirectoryFiles = define_c_func(ray,"+GetDirectoryFiles",{C_POINTER,C_POINTER},C_POINTER),
				xClearDirectoryFiles = define_c_proc(ray,"+ClearDirectoryFiles",{}),
				xChangeDirectory = define_c_func(ray,"+ChangeDirectory",{C_POINTER},C_BOOL),
				xIsFileDropped = define_c_func(ray,"+IsFileDropped",{},C_BOOL),
				xGetDroppedFiles = define_c_func(ray,"+GetDroppedFiles",{C_POINTER},C_POINTER),
				xClearDroppedFiles = define_c_proc(ray,"+ClearDroppedFiles",{}),
				xGetFileModTime = define_c_func(ray,"+GetFileModTime",{C_POINTER},C_LONG),
				xDirectoryExists = define_c_func(ray,"+DirectoryExists",{C_POINTER},C_BOOL),
				xGetPrevDirectoryPath = define_c_func(ray,"+GetPrevDirectoryPath",{C_POINTER},C_POINTER),
				xLoadFileData = define_c_func(ray,"+LoadFileData",{C_POINTER,C_POINTER},C_POINTER),
				xSaveFileData = define_c_proc(ray,"+SaveFileData",{C_POINTER,C_POINTER,C_INT}),
				xLoadFileText = define_c_func(ray,"+LoadFileText",{C_POINTER},C_POINTER),
				xSaveFileText = define_c_proc(ray,"+SaveFileText",{C_POINTER,C_POINTER})
				
public function FileExists(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xFileExists,{str})
	
end function

public function IsFileExtension(sequence file,sequence ext)

 atom str = allocate_string(file,1)
 atom ex = allocate_string(ext,1)
 
 return c_func(xIsFileExtension,{str,ex})
	
end function

public function GetExtension(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetExtension,{str})
	
end function

public function GetFileName(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetFileName,{str})
	
end function

public function GetFileNameWithoutExt(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetFileNameWithoutExt,{str})
	
end function

public function GetDirectoryPath(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetDirectoryPath,{str})
	
end function

public function GetWorkingDirectory()

 return c_func(xGetWorkingDirectory,{})
	
end function

public function GetDirectoryFiles(sequence path,atom count)

 atom str = allocate_string(path,1)
 
 return c_func(xGetDirectoryFiles,{str,count})
	
end function

public procedure ClearDirectoryFiles()

 c_proc(xClearDirectoryFiles,{})
	
end procedure

public function ChangeDirectory(sequence xdir)

 atom str = allocate_string(xdir,1)
 
 return c_func(xChangeDirectory,{str})
	
end function

public function IsFileDropped()

 return c_func(xIsFileDropped,{})
	
end function

public function GetDroppedFiles(atom count)

 return c_func(xGetDroppedFiles,{count})
	
end function

public procedure ClearDroppedFiles()

 c_proc(xClearDroppedFiles,{})
	
end procedure

public function GetFileModTime(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xGetFileModTime,{str})
	
end function

public function DirectoryExists(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xDirectoryExists,{str})
	
end function

public function GetPrevDirectoryPath(sequence path)

 atom str = allocate_string(path,1)
 
 return c_func(xGetPrevDirectoryPath,{str})
	
end function

public function LoadFileData(sequence file,atom bytes)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFileData,{str,bytes})
	
end function

public procedure SaveFileData(sequence file,object data,atom bytes)

 atom str = allocate_string(file,1)
 
 c_proc(xSaveFileData,{str,data,bytes})
	
end procedure

public function LoadFileText(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFileText,{str})
	
end function

public procedure SaveFileText(sequence file,sequence txt)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(txt,1)
 
 c_proc(xSaveFileText,{str,str2})
	
end procedure

--

public constant xCompressData = define_c_func(ray,"+CompressData",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xDecompressData = define_c_func(ray,"+DecompressData",{C_POINTER,C_INT,C_POINTER},C_POINTER)
				
public function CompressData(sequence data,atom len,atom datalen)

 atom str = allocate_string(data,1)
 
 return c_func(xCompressData,{str,len,datalen})
	
end function

public function DecompressData(sequence data,atom len,atom lendata)

 atom str = allocate_string(data,1)
 
 return c_func(xDecompressData,{str,len,lendata})
	
end function

--Storage Management Functions

public constant xGetStorageSaveValue = define_c_proc(ray,"+GetStorageSaveValue",{C_INT,C_INT}),
				xGetStorageLoadValue = define_c_func(ray,"+GetStorageLoadValue",{C_INT},C_INT),
				xOpenURL = define_c_proc(ray,"+OpenURL",{C_POINTER})
				
public procedure GetStorageSaveValue(atom pos,atom val)

 c_proc(xGetStorageSaveValue,{pos,val})
	
end procedure

public function GetStorageLoadValue(atom pos)

 return c_func(xGetStorageLoadValue,{pos})
	
end function

public procedure OpenURL(sequence url)

 atom str = allocate_string(url,1)
 
 c_proc(xOpenURL,{str})
	
end procedure

--Input Functions (Keyboard)

public constant xIsKeyPressed = define_c_func(ray,"+IsKeyPressed",{C_INT},C_BOOL),
				xIsKeyDown = define_c_func(ray,"+IsKeyDown",{C_INT},C_BOOL),
				xIsKeyReleased = define_c_func(ray,"+IsKeyReleased",{C_INT},C_BOOL),
				xIsKeyUp = define_c_func(ray,"+IsKeyUp",{C_INT},C_BOOL),
				xGetKeyPressed = define_c_func(ray,"+GetKeyPressed",{},C_INT),
				xSetExitKey = define_c_proc(ray,"+SetExitKey",{C_INT})
				
public function IsKeyPressed(atom key)

 return c_func(xIsKeyPressed,{key})
	
end function

public function IsKeyDown(atom key)

 return c_func(xIsKeyDown,{key})
	
end function

public function IsKeyReleased(atom key)

 return c_func(xIsKeyReleased,{key})
	
end function

public function IsKeyUp(atom key)

 return c_func(xIsKeyUp,{key})
	
end function

public function GetKeyPressed()

 return c_func(xGetKeyPressed,{})
	
end function

public procedure SetExitKey(atom key)

 c_proc(xSetExitKey,{key})
	
end procedure

--Input Functions (Gamepad)

public constant xIsGamepadAvailable = define_c_func(ray,"+IsGamepadAvailable",{C_INT},C_BOOL),
				xIsGamepadName = define_c_func(ray,"+IsGamepadName",{C_INT,C_POINTER},C_BOOL),
				xGetGamepadName = define_c_func(ray,"+GetGamepadName",{C_INT},C_POINTER),
				xIsGamepadButtonPressed = define_c_func(ray,"+IsGamepadButtonPressed",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonDown = define_c_func(ray,"+IsGamepadButtonDown",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonReleased = define_c_func(ray,"+IsGamepadButtonReleased",{C_INT,C_INT},C_BOOL),
				xIsGamepadButtonUp = define_c_func(ray,"+IsGamepadButtonUp",{C_INT,C_INT},C_BOOL),
				xGetGamepadButtonPressed = define_c_func(ray,"+GetGamepadButtonPressed",{},C_INT),
				xGetGamepadAxisCount = define_c_func(ray,"+GetGamepadAxisCount",{C_INT},C_INT),
				xGetGamepadAxisMovement = define_c_func(ray,"+GetGamepadAxisMovement",{C_INT,C_INT},C_FLOAT)
				
public function IsGamepadAvailable(atom pad)

 return c_func(xIsGamepadAvailable,{pad})
	
end function

public function IsGamepadName(atom pad,sequence name)

 atom str = allocate_string(name,1)
 
 return c_func(xIsGamepadName,{pad,str})
	
end function

public function GetGamepadName(atom pad)

 return c_func(xGetGamepadName,{pad})
	
end function

public function IsGamepadButtonPressed(atom pad,atom btn)

 return c_func(xIsGamepadButtonPressed,{pad,btn})
	
end function

public function IsGamepadButtonDown(atom pad,atom btn)

 return c_func(xIsGamepadButtonDown,{pad,btn})
	
end function

public function IsGamepadButtonReleased(atom pad,atom btn)

 return c_func(xIsGamepadButtonReleased,{pad,btn})
	
end function

public function IsGamepadButtonUp(atom pad,atom btn)

 return c_func(xIsGamepadButtonUp,{pad,btn})
	
end function

public function GetGamepadButtonPressed()

 return c_func(xGetGamepadButtonPressed,{})
	
end function

public function GetGamepadAxisCount(atom pad)

 return c_func(xGetGamepadAxisCount,{pad})
	
end function

public function GetGamepadAxisMovement(atom pad,atom axis)

 return c_func(xGetGamepadAxisMovement,{pad,axis})
	
end function

--Input Functions (Mouse)

public constant xIsMouseButtonPressed = define_c_func(ray,"+IsMouseButtonPressed",{C_INT},C_BOOL),
				xIsMouseButtonDown = define_c_func(ray,"+IsMouseButtonDown",{C_INT},C_BOOL),
				xIsMouseButtonReleased = define_c_func(ray,"+IsMouseButtonReleased",{C_INT},C_BOOL),
				xIsMouseButtonUp = define_c_func(ray,"+IsMouseButtonUp",{C_INT},C_BOOL),
				xGetMouseX = define_c_func(ray,"+GetMouseX",{},C_INT),
				xGetMouseY = define_c_func(ray,"+GetMouseY",{},C_INT),
				xGetMousePosition = define_c_func(ray,"+GetMousePosition",{},C_FLOAT),
				xSetMousePosition = define_c_proc(ray,"+SetMousePosition",{C_INT,C_INT}),
				xSetMouseOffset = define_c_proc(ray,"+SetMouseOffset",{C_INT,C_INT}),
				xSetMouseScale = define_c_proc(ray,"+SetMouseScale",{C_FLOAT,C_FLOAT}),
				xGetMouseWheelMove = define_c_func(ray,"+GetMouseWheelMove",{},C_INT),
				xGetMouseCursor = define_c_func(ray,"+GetMouseCursor",{},C_INT),
				xSetMouseCursor = define_c_proc(ray,"+SetMouseCursor",{C_INT})
				
public function IsMouseButtonPressed(atom btn)

 return c_func(xIsMouseButtonPressed,{btn})
	
end function

public function IsMouseButtonDown(atom btn)

 return c_func(xIsMouseButtonDown,{btn})
	
end function

public function IsMouseButtonReleased(atom btn)

 return c_func(xIsMouseButtonReleased,{btn})
	
end function

public function IsMouseButtonUp(atom btn)

 return c_func(xIsMouseButtonUp,{btn})
	
end function

public function GetMouseX()

 return c_func(xGetMouseX,{})
	
end function

public function GetMouseY()

 return c_func(xGetMouseY,{})
	
end function

public function GetMousePosition()

 return c_func(xGetMousePosition,{})
	
end function

public procedure SetMousePosition(atom x,atom y)

 c_proc(xSetMousePosition,{x,y})
	
end procedure

public procedure SetMouseOffset(atom x,atom y)

 c_proc(xSetMouseOffset,{x,y})
	
end procedure

public procedure SetMouseScale(atom x,atom y)

 c_proc(xSetMouseScale,{x,y})
	
end procedure

public function GetMouseWheelMove()

 return c_func(xGetMouseWheelMove,{})
	
end function

public function GetMouseCursor()

 return c_func(xGetMouseCursor,{})
	
end function

public procedure SetMouseCursor(atom cur)

 c_proc(xSetMouseCursor,{cur})
	
end procedure

--Input Functions (Touch)

public constant xGetTouchX = define_c_func(ray,"+GetTouchX",{},C_INT),
				xGetTouchY = define_c_func(ray,"+GetTouchY",{},C_INT),
				xGetTouchPosition = define_c_func(ray,"+GetTouchPosition",{},C_INT)
				
public function GetTouchX()

 return c_func(xGetTouchX,{})
	
end function

public function GetTouchY()

 return c_func(xGetTouchY,{})
	
end function

public function GetTouchPosition()

 return c_func(xGetTouchPosition,{})
	
end function

--Input Functions (Gestures)

public constant xSetGesturesEnabled = define_c_proc(ray,"+SetGesturesEnabled",{C_UINT}),
				xIsGestureDetected = define_c_func(ray,"+IsGestureDetected",{C_INT},C_BOOL),
				xGetGestureDetected = define_c_func(ray,"+GetGestureDetected",{},C_INT),
				xGetTouchPointsCount = define_c_func(ray,"+GetTouchPointsCount",{},C_INT),
				xGetGestureHoldDuration = define_c_func(ray,"+GetGestureHoldDuration",{},C_FLOAT),
				xGetGestureDragVector = define_c_func(ray,"+GetGestureDragVector",{},C_FLOAT),
				xGetGestureDragAngle = define_c_func(ray,"+GetGestureDragAngle",{},C_FLOAT),
				xGetGesturePinchVector = define_c_func(ray,"+GetGesturePinchVector",{},C_FLOAT),
				xGetGesturePinchAngle = define_c_func(ray,"+GetGesturePinchAngle",{},C_FLOAT)
				
public procedure SetGesturesEnabled(atom flags)

 c_proc(xSetGesturesEnabled,{flags})
	
end procedure

public function IsGestureDetected(atom ges)

 return c_func(xIsGestureDetected,{ges})
	
end function

public function GetGestureDetected()

 return c_func(xGetGestureDetected,{})
	
end function

public function GetTouchPointsCount()

 return c_func(xGetTouchPointsCount,{})
	
end function

public function GetGestureHoldDuration()

 return c_func(xGetGestureHoldDuration,{})
	
end function

public function GetGestureDragVector()

 return c_func(xGetGestureDragVector,{})
	
end function

public function GetGestureDragAngle()

 return c_func(xGetGestureDragAngle,{})
	
end function

public function GetGesturePinchVector()

 return c_func(xGetGesturePinchVector,{})
	
end function

public function GetGesturePinchAngle()

 return c_func(xGetGesturePinchAngle,{})
	
end function

--Camera Functions

public constant xSetCameraMode = define_c_proc(ray,"+SetCameraMode",{C_POINTER,C_INT}),
				xUpdateCamera = define_c_proc(ray,"+UpdateCamera",{C_POINTER}),
				xSetCameraPanControl = define_c_proc(ray,"+SetCameraPanControl",{C_INT}),
				xSetCameraAltControl = define_c_proc(ray,"+SetCameraAltControl",{C_INT}),
				xSetCameraSmoothZoomControl = define_c_proc(ray,"+SetCameraSmoothZoomControl",{C_INT}),
				xSetCameraMoveControls = define_c_proc(ray,"+SetCameraMoveControls",{C_INT,C_INT,C_INT,C_INT,C_INT,C_INT})
				
public procedure SetCameraMode(atom cam,atom mod)

 c_proc(xSetCameraMode,{cam,mod})
	
end procedure

public procedure UpdateCamera(atom cam)

 c_proc(xUpdateCamera,{cam})
	
end procedure

public procedure SetCameraPanControl(atom pan)

 c_proc(xSetCameraPanControl,{pan})
	
end procedure

public procedure SetCameraAltControl(atom alt)

 c_proc(xSetCameraAltControl,{alt})
	
end procedure

public procedure SetCameraSmoothZoomControl(atom sz)

 c_proc(xSetCameraSmoothZoomControl,{sz})
	
end procedure

public procedure SetCameraMoveControls(atom front,atom back,atom right,atom left,atom up,atom down)

 c_proc(xSetCameraMoveControls,{front,back,right,left,up,down})
	
end procedure

--End of Core Module Functions

--Shape Module Functions

public constant xDrawPixel = define_c_proc(ray,"+DrawPixel",{C_INT,C_INT,C_UINT}),
				xDrawPixelV = define_c_proc(ray,"+DrawPixelV",{C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLine = define_c_proc(ray,"+DrawLine",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawLineV = define_c_proc(ray,"+DrawLineV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineEx = define_c_proc(ray,"+DrawLineEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineBezier = define_c_proc(ray,"+DrawLineBezier",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawLineStrip = define_c_proc(ray,"+DrawLineStrip",{C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawCircle = define_c_proc(ray,"+DrawCircle",{C_INT,C_INT,C_FLOAT,C_UINT}),
				xDrawCircleSector = define_c_proc(ray,"+DrawCircleSector",{C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawCircleSectorLines = define_c_proc(ray,"+DrawCircleSectorLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawCircleGradient = define_c_proc(ray,"+DrawCircleGradient",{C_INT,C_INT,C_FLOAT,C_POINTER,C_UINT}),
				xDrawCircleV = define_c_proc(ray,"+DrawCircleV",{C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCircleLines = define_c_proc(ray,"+DrawCircleLines",{C_INT,C_INT,C_FLOAT,C_UINT}),
				xDrawRing = define_c_proc(ray,"+DrawRing",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRingLines = define_c_proc(ray,"+DrawRingLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRectangle = define_c_proc(ray,"+DrawRectangle",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRectangleV = define_c_proc(ray,"+DrawRectangleV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectangleRec = define_c_proc(ray,"+DrawRectangleRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectanglePro = define_c_proc(ray,"+DrawRectanglePro",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRectangleGradientV = define_c_proc(ray,"+DrawRectangleGradientV",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT}),
				xDrawRectangleGradientH = define_c_proc(ray,"+DrawRectangleGradientH",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT}),
				xDrawRectangleGradientEx = define_c_proc(ray,"+DrawRectangleGradientEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT,C_UINT,C_UINT,C_UINT}),
				xDrawRectangleLines = define_c_proc(ray,"+DrawRectangleLines",{C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawRectangleLinesEx = define_c_proc(ray,"+DrawRectangleLinesEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawRectangleRounded = define_c_proc(ray,"+DrawRectangleRounded",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawRectangleRoundedLines = define_c_proc(ray,"+DrawRectangleRoundedLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_UINT}),
				xDrawTriangle = define_c_proc(ray,"+DrawTriangle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangleLines = define_c_proc(ray,"+DrawTriangleLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTriangleFan = define_c_proc(ray,"+DrawTriangleFan",{C_POINTER,C_POINTER,C_INT,C_UINT}),
				xDrawPoly = define_c_proc(ray,"+DrawPoly",{C_FLOAT,C_FLOAT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				
				xSetShapesTexture = define_c_proc(ray,"+SetShapesTexture",{C_POINTER,C_POINTER}),
				
				xCheckCollisionRecs = define_c_func(ray,"+CheckCollisionRecs",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionCircles = define_c_func(ray,"+CheckCollisionCircles",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionCircleRec = define_c_func(ray,"+CheckCollisionCircleRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xGetCollisionRec = define_c_func(ray,"+GetCollisionRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT),
				xCheckCollisionPointRec = define_c_func(ray,"+CheckCollisionPointRec",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionPointCircle = define_c_func(ray,"+CheckCollisionPointCircle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionPointTrangle = define_c_func(ray,"+CheckCollisionPointTriangle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionLines = define_c_func(ray,"+CheckCollisionLines",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER},C_BOOL),
				
				xDrawTriangleStrip = define_c_proc(ray,"+DrawTriangleStrip",{C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawEllipse = define_c_proc(ray,"+DrawEllipse",{C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawEllipseLines = define_c_proc(ray,"+DrawEllipseLines",{C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawPixel(atom x,atom y,atom col)

 c_proc(xDrawPixel,{x,y,col})
	
end procedure

public procedure DrawPixelV(atom x,atom y,atom col)

 c_proc(xDrawPixelV,{x,y,col})
	
end procedure

public procedure DrawLine(atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xDrawLine,{x,y,x2,y2,col})
	
end procedure

public procedure DrawLineV(atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xDrawLineV,{x,y,x2,y2})
	
end procedure

public procedure DrawLineEx(atom x,atom y,atom x2,atom y2,atom thick,atom col)

 c_proc(xDrawLineEx,{x,y,x2,y2,thick,col})
	
end procedure

public procedure DrawLineBezier(atom x,atom y,atom x2,atom y2,atom thick,atom col)

 c_proc(xDrawLineBezier,{x,y,x2,y2,thick,col})
	
end procedure

public procedure DrawLineStrip(atom x,atom y,atom num,atom col)

 c_proc(xDrawLineStrip,{x,y,num,col})
	
end procedure

public procedure DrawCircle(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircle,{x,y,rad,col})
	
end procedure

public procedure DrawCircleSector(atom x,atom y,atom rad,atom start,atom xend,atom segs,atom col)

 c_proc(xDrawCircleSector,{x,y,rad,start,xend,segs,col})
	
end procedure

public procedure DrawCircleSectorLines(atom x,atom y,atom rad,atom start,atom segs,atom col)

 c_proc(xDrawCircleSectorLines,{x,y,rad,start,segs,col})
	
end procedure

public procedure DrawCircleGradient(atom x,atom y,atom rad,atom col,atom col2)

 c_proc(xDrawCircleGradient,{x,y,rad,col,col2})
	
end procedure

public procedure DrawCircleV(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircleV,{x,y,rad,col})
	
end procedure

public procedure DrawCircleLines(atom x,atom y,atom rad,atom col)

 c_proc(xDrawCircleLines,{x,y,rad,col})
	
end procedure

public procedure DrawRing(atom x,atom y,atom inner,atom outer,atom start,atom xend,atom segs,atom col)

 c_proc(xDrawRing,{x,y,inner,outer,start,xend,segs,col})
	
end procedure

public procedure DrawRingLines(atom x,atom y,atom inner,atom outer,atom start,atom xend,atom segs,atom col)

 c_proc(xDrawRingLines,{x,y,inner,outer,start,xend,segs,col})
	
end procedure

public procedure DrawRectangle(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangle,{x,y,w,h,col})
	
end procedure

public procedure DrawRectangleV(atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xDrawRectangleV,{x,y,x2,y2,col})
	
end procedure

public procedure DrawRectangleRec(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangleRec,{x,y,w,h,col})
	
end procedure

public procedure DrawRectanglePro(atom rx,atom ry,atom rw,atom rh,atom x,atom y,atom rot,atom col)

 c_proc(xDrawRectanglePro,{rx,ry,rw,rh,x,y,rot,col})
	
end procedure

public procedure DrawRectangleGradientV(atom x,atom y,atom w,atom h,atom col,atom col2)

 c_proc(xDrawRectangleGradientV,{x,y,w,h,col,col2})
	
end procedure

public procedure DrawRectangleGradientH(atom x,atom y,atom w,atom h,atom col,atom col2)

 c_proc(xDrawRectangleGradientH,{x,y,w,h,col,col2})
	
end procedure

public procedure DrawRectangleGradientEx(atom x,atom y,atom w,atom h,atom col,atom col2,atom col3,atom col4)

 c_proc(xDrawRectangleGradientEx,{x,y,w,h,col,col2,col3,col4})
	
end procedure

public procedure DrawRectangleLines(atom x,atom y,atom w,atom h,atom col)

 c_proc(xDrawRectangleLines,{x,y,w,h,col})
	
end procedure

public procedure DrawRectangleLinesEx(atom x,atom y,atom w,atom h,atom thick,atom col)

 c_proc(xDrawRectangleLinesEx,{x,y,w,h,thick,col})
	
end procedure

public procedure DrawRectangleRounded(atom x,atom y,atom w,atom h,atom round,atom segs,atom col)

 c_proc(xDrawRectangleRounded,{x,y,w,h,round,segs,col})
	
end procedure

public procedure DrawRectangleRoundedLines(atom x,atom y,atom w,atom h,atom round,atom segs,atom thick,atom col)

 c_proc(xDrawRectangleRoundedLines,{x,y,w,h,round,segs,thick,col})
	
end procedure

public procedure DrawTriangle(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom col)

 c_proc(xDrawTriangle,{x,y,x2,y2,x3,y3,col})
	
end procedure

public procedure DrawTriangleLines(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom col)

 c_proc(xDrawTriangleLines,{x,y,x2,y2,x3,y3,col})
	
end procedure

public procedure DrawTriangleFan(atom x,atom y,atom num,atom col)

 c_proc(xDrawTriangleFan,{x,y,num,col})
	
end procedure

public procedure DrawPoly(atom x,atom y,atom sides,atom rad,atom rot,atom col)

 c_proc(xDrawPoly,{x,y,sides,rad,rot,col})
	
end procedure

public procedure SetShapesTexture(atom tex,atom src)

 c_proc(xSetShapesTexture,{tex,src})
	
end procedure

public procedure DrawTriangleStrip(atom x,atom y,atom pc,atom col)

 c_proc(xDrawTriangleStrip,{x,y,pc,col})
	
end procedure

public procedure DrawEllipse(atom x,atom y,atom radh,atom radv,atom col)

 c_proc(xDrawEllipse,{x,y,radh,radv,col})
	
end procedure

public procedure DrawEllipseLines(atom x,atom y,atom radh,atom radv,atom col)

 c_proc(xDrawEllipseLines,{x,y,radh,radv,col})
	
end procedure

public function CheckCollisionRecs(atom x,atom y,atom w,atom h,atom x2,atom y2,atom w2,atom h2)

 return c_func(xCheckCollisionRecs,{x,y,w,h,x2,y2,w2,h2})
	
end function

public function CheckCollisionCircles(atom x,atom y,atom rad,atom x2,atom y2,atom rad2)

 return c_func(xCheckCollisionCircles,{x,y,rad,x2,y2,rad2})
	
end function

public function CheckCollisionCircleRec(atom x,atom y,atom rad,atom x2,atom y2,atom w,atom h)

 return c_func(xCheckCollisionCircleRec,{x,y,rad,x2,y2,w,h})
	
end function

public function GetCollisionRec(atom x,atom y,atom w,atom h,atom x2,atom y2,atom w2,atom h2)

 return c_func(xGetCollisionRec,{x,y,w,h,x2,y2,w2,h2})
	
end function

public function CheckCollisionPointRec(atom x,atom y,atom x2,atom y2,atom w,atom h)

 return c_func(xCheckCollisionPointRec,{x,y,x2,y2,w,h})
	
end function

public function CheckCollisionLines(atom x,atom y,atom x2,atom y2,atom x3,atom y3,atom x4,atom y4,atom px,atom py)

 return c_func(xCheckCollisionLines,{x,y,x2,y2,x3,y3,x4,y4,px,py})
	
end function

--End Shape Module Functions

--Texture Module Functions

--constant C_TEXTURE2D = {C_UINT,C_INT,C_INT,C_INT,C_INT}

public constant xLoadImage = define_c_func(ray,"+LoadImage",{C_POINTER},C_POINTER),
				xLoadImageEx = define_c_func(ray,"+LoadImageEx",{C_POINTER,C_INT,C_INT},C_POINTER),
				xLoadImagePro = define_c_func(ray,"+LoadImagePro",{C_POINTER,C_INT,C_INT,C_INT},C_POINTER),
				xLoadImageRaw = define_c_func(ray,"+LoadImageRaw",{C_POINTER,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xExportImage = define_c_proc(ray,"+ExportImage",{C_POINTER,C_POINTER}),
				xExportImageAsCode = define_c_proc(ray,"+ExportImageAsCode",{C_POINTER,C_POINTER}),
				xLoadTexture = define_c_func(ray,"+LoadTexture",{C_POINTER},C_UINT),
				xLoadTextureFromImage = define_c_func(ray,"+LoadTextureFromImage",{C_POINTER},C_POINTER),
				xLoadTextureCubemap = define_c_func(ray,"+LoadTextureCubemap",{C_POINTER,C_INT},C_POINTER),
				xLoadRenderTexture = define_c_func(ray,"+LoadRenderTexture",{C_INT,C_INT},C_POINTER),
				xUnloadImage = define_c_proc(ray,"+UnloadImage",{C_POINTER}),
				xUnloadRenderTexture = define_c_proc(ray,"+UnloadRenderTexture",{C_POINTER}),
				xUnloadTexture = define_c_proc(ray,"+UnloadTexture",{C_POINTER}),
				xGetImageData = define_c_func(ray,"+GetImageData",{C_POINTER},C_POINTER),
				xGetImageDataNormalized = define_c_func(ray,"+GetImageDataNormalized",{C_POINTER},C_FLOAT),
				xGetPixelDataSize = define_c_func(ray,"+GetPixelDataSize",{C_INT,C_INT,C_INT},C_INT),
				xGetTextureData = define_c_func(ray,"+GetTextureData",{C_POINTER},C_POINTER),
				xGetScreenData = define_c_func(ray,"+GetScreenData",{},C_POINTER),
				xUpdateTexture = define_c_proc(ray,"+UpdateTexture",{C_POINTER,C_POINTER})
				
public function LoadImage(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImage,{str})
	
end function

public function LoadImageEx(atom pix,atom w,atom h)

 return c_func(xLoadImageEx,{pix,w,h})
	
end function

public function LoadImagePro(object data,atom w,atom h,atom format)

 return c_func(xLoadImagePro,{data,w,h,format})
	
end function

public function LoadImageRaw(sequence file,atom w,atom h,atom format,atom size)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImageRaw,{str,w,h,format,size})
	
end function

public procedure ExportImage(atom img,sequence file)

 atom str = allocate_string(file,1)
  
 c_proc(xExportImage,{img,str})
	
end procedure

public procedure ExportImageAsCode(atom img,sequence file)

 atom str = allocate_string(file,1)
 
 c_proc(xExportImageAsCode,{img,str})
	
end procedure

public function LoadTexture(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadTexture,{str})
	
end function

public function LoadTextureFromImage(atom img)

 return c_func(xLoadTextureFromImage,{img})
	
end function

public function LoadTextureCubemap(atom img,atom xtype)

 return c_func(xLoadTextureCubemap,{img,xtype})
	
end function

public function LoadRenderTexture(atom w,atom h)

 return c_func(xLoadRenderTexture,{w,h})
	
end function

public procedure UnloadImage(atom img)

 c_proc(xUnloadImage,{img})
	
end procedure

public procedure UnloadTexture(atom tex)

 c_proc(xUnloadTexture,{tex})
	
end procedure

public procedure UnloadRenderTexture(atom target)

 c_proc(xUnloadRenderTexture,{target})
	
end procedure

public function GetImageData(atom img)

 return c_func(xGetImageData,{img})
	
end function

public function GetImageDataNormalized(atom img)

 return c_func(xGetImageDataNormalized,{img})
	
end function

public function GetPixelDataSize(atom w,atom h,atom format)

 return c_func(xGetPixelDataSize,{w,h,format})
	
end function

public function GetTextureData(atom tex)

 return c_func(xGetTextureData,{tex})
	
end function

public function GetScreenData()

 return c_func(xGetScreenData,{})
	
end function

public procedure UpdateTexture(atom tex,object pix)

 c_proc(xUpdateTexture,{tex,pix})
	
end procedure

public constant xLoadImageFromMemory = define_c_func(ray,"+LoadImageFromMemory",{C_POINTER,C_POINTER,C_INT},C_POINTER)

public function LoadImageFromMemory(sequence file,sequence dat,atom size)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(dat,1)
 
 return c_func(xLoadImageFromMemory,{str,str2,size})
	
end function

public constant xLoadImageAnim = define_c_func(ray,"+LoadImageAnim",{C_POINTER,C_POINTER},C_POINTER)

public function LoadImageAnim(sequence file,atom frame)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadImageAnim,{str,frame})
	
end function

--Image manipulation 

public constant xImageCopy = define_c_func(ray,"+ImageCopy",{C_POINTER},C_POINTER),
				xImageToPOT = define_c_proc(ray,"+ImageToPOT",{C_POINTER,C_UINT}),
				xImageFormat = define_c_proc(ray,"+ImageFormat",{C_POINTER,C_INT}),
				xImageAlphaMask = define_c_proc(ray,"+ImageAlphaMask",{C_POINTER,C_POINTER}),
				xImageAlphaClear = define_c_proc(ray,"+ImageAlphaClear",{C_POINTER,C_POINTER,C_FLOAT}),
				xImageAlphaCrop = define_c_proc(ray,"+ImageAlphaCrop",{C_POINTER,C_FLOAT}),
				xImageAlphaPremultiply = define_c_proc(ray,"+ImageAlphaPremultiply",{C_POINTER}),
				xImageCrop = define_c_proc(ray,"+ImageCrop",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT}),
				xImageResize = define_c_proc(ray,"+ImageResize",{C_POINTER,C_INT,C_INT}),
				xImageResizeNN = define_c_proc(ray,"+ImageResizeNN",{C_POINTER,C_INT,C_INT}),
				xImageResizeCanvas = define_c_proc(ray,"+ImageResizeCanvas",{C_POINTER,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xImageMipmaps = define_c_proc(ray,"+ImageMipmaps",{C_POINTER}),
				xImageDither = define_c_proc(ray,"+ImageDither",{C_POINTER,C_INT,C_INT,C_INT,C_INT}),
				xImageExtractPalette = define_c_func(ray,"+ImageExtractPalette",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xImageText = define_c_func(ray,"+ImageText",{C_POINTER,C_INT,C_UINT},C_POINTER),
				xImageTextEx = define_c_func(ray,"+ImageTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_UINT},C_POINTER),
				xImageDraw = define_c_proc(ray,"+ImageDraw",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT}),
				xImageDrawRectangle = define_c_proc(ray,"+ImageDrawRectangle",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawRectangleLines = define_c_proc(ray,"+ImageDrawRectangleLines",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xImageDrawText = define_c_proc(ray,"+ImageDrawText",{C_POINTER,C_FLOAT,C_FLOAT,C_POINTER,C_INT,C_UINT}),
				xImageDrawTextEx = define_c_proc(ray,"+ImageDrawTextEx",{C_POINTER,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_UINT}),
				xImageFlipVertical = define_c_proc(ray,"+ImageFlipVertical",{C_POINTER}),
				xImageFlipHorizontal = define_c_proc(ray,"+ImageFlipHorizontal",{C_POINTER}),
				xImageRotateCW = define_c_proc(ray,"+ImageRotateCW",{C_POINTER}),
				xImageRotateCCW = define_c_proc(ray,"+ImageRotateCCW",{C_POINTER}),
				xImageColorTint = define_c_proc(ray,"+ImageColorTint",{C_POINTER,C_UINT}),
				xImageColorInvert = define_c_proc(ray,"+ImageColorInvert",{C_POINTER}),
				xImageColorGrayscale = define_c_proc(ray,"+ImageColorGrayscale",{C_POINTER}),
				xImageColorContrast = define_c_proc(ray,"+ImageColorContrast",{C_POINTER,C_FLOAT}),
				xImageColorBrightness = define_c_proc(ray,"+ImageColorBrightness",{C_POINTER,C_INT}),
				xImageColorReplace = define_c_proc(ray,"+ImageColorReplace",{C_POINTER,C_UINT,C_UINT}),
				xGetImageAlphaBorder = define_c_func(ray,"+GetImageAlphaBorder",{C_POINTER,C_FLOAT},C_FLOAT),
				xImageFromImage = define_c_func(ray,"+ImageFromImage",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)
				
public function ImageCopy(atom img)

 return c_func(xImageCopy,{img})
	
end function

public procedure ImageToPOT(atom img,atom col)

 c_proc(xImageToPOT,{img,col})
	
end procedure

public procedure ImageFormat(atom img,atom format)

 c_proc(xImageFormat,{img,format})
	
end procedure

public procedure ImageAlphaMask(atom img,atom mask)

 c_proc(xImageAlphaMask,{img,mask})
	
end procedure

public procedure ImageAlphaClear(atom img,atom col,atom hold)

 c_proc(xImageAlphaClear,{img,col,hold})
	
end procedure

public procedure ImageAlphaCrop(atom img,atom hold)

 c_proc(xImageAlphaCrop,{img,hold})
	
end procedure

public procedure ImageAlphaPremultiply(atom img)

 c_proc(xImageAlphaPremultiply,{img})
	
end procedure

public procedure ImageCrop(atom img,atom x,atom y,atom w,atom h)

 c_proc(xImageCrop,{img,x,y,w,h})
	
end procedure

public procedure ImageResize(atom img,atom w,atom h)

 c_proc(xImageResize,{img,w,h})
	
end procedure

public procedure ImageResizeNN(atom img,atom w,atom h)

 c_proc(xImageResizeNN,{img,w,h})
	
end procedure

public procedure ImageResizeCanvas(atom img,atom w,atom h,atom x,atom y,atom col)

 c_proc(xImageResizeCanvas,{img,w,h,x,y,col})
	
end procedure

public procedure ImageMipmaps(atom img)

 c_proc(xImageMipmaps,{img})
	
end procedure

public procedure ImageDither(atom img,atom r,atom g,atom b,atom a)

 c_proc(xImageDither,{img,r,g,b,a})
	
end procedure

public function ImageExtractPalette(atom img,atom max,atom count)

 return c_func(xImageExtractPalette,{img,max,count})
	
end function

public function ImageText(sequence file,atom size,atom col)

 atom str = allocate_string(file,1)
 
 return c_func(xImageText,{str,size,col})
	
end function

public function ImageTextEx(atom font,sequence text,atom size,atom space,atom tint)

 atom str = allocate_string(text,1)
 
 return c_func(xImageTextEx,{font,str,size,space,tint})
	
end function

public procedure ImageDraw(atom dst,atom src,atom sx,atom sy,atom sw,atom sh,atom dx,atom dy,atom dw,atom dh)

 c_proc(xImageDraw,{dst,src,sx,sy,sw,sh,dx,dy,dw,dh})
	
end procedure

public procedure ImageDrawRectangle(atom dst,atom x,atom y,atom w,atom h,atom col)

 c_proc(xImageDrawRectangle,{dst,x,y,w,h,col})
	
end procedure

public procedure ImageDrawRectangleLines(atom dst,atom x,atom y,atom w,atom h,atom thick,atom col)

 c_proc(xImageDrawRectangleLines,{dst,x,y,w,h,thick,col})
	
end procedure

public procedure ImageDrawText(atom dst,atom x,atom y,sequence text,atom size,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xImageDrawText,{dst,x,y,str,size,col})
	
end procedure

public procedure ImageDrawTextEx(atom dst,atom x,atom y,atom font,sequence text,atom size,atom space,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xImageDrawTextEx,{dst,x,y,font,str,size,space,col})
	
end procedure

public procedure ImageFlipVertical(atom img)

 c_proc(xImageFlipVertical,{img})
	
end procedure

public procedure ImageFlipHorizontal(atom img)

 c_proc(xImageFlipHorizontal,{img})
	
end procedure

public procedure ImageRotateCW(atom img)

 c_proc(xImageRotateCW,{img})
	
end procedure

public procedure ImageRotateCCW(atom img)

 c_proc(xImageRotateCCW,{img})
	
end procedure

public procedure ImageColorTint(atom img,atom col)

 c_proc(xImageColorTint,{img,col})
	
end procedure

public procedure ImageColorInvert(atom img)

 c_proc(xImageColorInvert,{img})
	
end procedure

public procedure ImageColorGrayscale(atom img)

 c_proc(xImageColorGrayscale,{img})
	
end procedure

public procedure ImageColorContrast(atom img,atom con)

 c_proc(xImageColorContrast,{img,con})
	
end procedure

public procedure ImageColorBrightness(atom img,atom bright)

 c_proc(xImageColorBrightness,{img,bright})
	
end procedure

public procedure ImageColorReplace(atom img,atom col,atom replace)

 c_proc(xImageColorReplace,{img,col,replace})
	
end procedure

public function GetImageAlphaBorder(atom img,atom thres)

 return c_func(xGetImageAlphaBorder,{img,thres})
	
end function

public function ImageFromImage(atom img,atom x,atom y,atom w,atom h)

 return c_func(xImageFromImage,{img,x,y,w,h})
	
end function

--Image Generation

public constant xGenImageColor = define_c_func(ray,"+GenImageColor",{C_INT,C_INT,C_UINT},C_POINTER),
				xGenImageGradientV = define_c_func(ray,"+GenImageGradientV",{C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageGradientH = define_c_func(ray,"+GenImageGradientH",{C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageGradientRadial = define_c_func(ray,"+GenImageGradientRadial",{C_INT,C_INT,C_FLOAT,C_UINT,C_UINT},C_POINTER),
				xGenImageChecked = define_c_func(ray,"+GenImageChecked",{C_INT,C_INT,C_INT,C_INT,C_UINT,C_UINT},C_POINTER),
				xGenImageWhiteNoise = define_c_func(ray,"+GenImageWhiteNoise",{C_INT,C_INT,C_FLOAT},C_POINTER),
				xGenImagePerlinNoise = define_c_func(ray,"+GenImagePerlinNoise",{C_INT,C_INT,C_INT,C_INT,C_FLOAT},C_POINTER),
				xGenImageCellular = define_c_func(ray,"+GenImageCellular",{C_INT,C_INT,C_INT},C_POINTER)
				
public function GenImageColor(atom w,atom h,atom col)

 return c_func(xGenImageColor,{w,h,col})
	
end function

public function GenImageGradientV(atom w,atom h,atom top,atom bot)

 return c_func(xGenImageGradientV,{w,h,top,bot})
	
end function

public function GenImageGradientH(atom w,atom h,atom left,atom right)

 return c_func(xGenImageGradientH,{w,h,left,right})
	
end function

public function GenImageGradientRadial(atom w,atom h,atom dens,atom inner,atom outer)

 return c_func(xGenImageGradientRadial,{w,h,dens,inner,outer})
	
end function

public function GenImageChecked(atom w,atom h,atom x,atom y,atom col,atom col2)

 return c_func(xGenImageChecked,{w,h,x,y,col,col2})
	
end function

public function GenImageWhiteNoise(atom w,atom h,atom fac)

 return c_func(xGenImageWhiteNoise,{w,h,fac})
	
end function

public function GenImagePerlinNoise(atom w,atom h,atom x,atom y,atom scale)

 return c_func(xGenImagePerlinNoise,{w,h,x,y,scale})
	
end function

public function GenImageCelluar(atom w,atom h,atom size)

 return c_func(xGenImageCellular,{w,h,size})
	
end function

--Texture Config

public constant xGenTextureMipmaps = define_c_proc(ray,"+GenTextureMipmaps",{C_POINTER}),
				xSetTextureFilter = define_c_proc(ray,"+SetTextureFilter",{C_POINTER,C_INT}),
				xSetTextureWrap = define_c_proc(ray,"+SetTextureWrap",{C_POINTER,C_INT})
				
public procedure GenTextureMipmaps(atom tex)

 c_proc(xGenTextureMipmaps,{tex})
	
end procedure

public procedure SetTextureFilter(atom tex,atom mode)

 c_proc(xSetTextureFilter,{tex,mode})
	
end procedure

public procedure SetTextureWrap(atom tex,atom mode)

 c_proc(xSetTextureWrap,{tex,mode})
	
end procedure

--Texture Drawing

public constant xDrawTexture = define_c_proc(ray,"+DrawTexture",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_INT,C_UINT}),
				xDrawTextureV = define_c_proc(ray,"+DrawTextureV",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureEx = define_c_proc(ray,"+DrawTextureEx",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureRec = define_c_proc(ray,"+DrawTextureRec",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureQuad = define_c_proc(ray,"+DrawTextureQuad",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTexturePro = define_c_proc(ray,"+DrawTexturePro",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextureNPatch = define_c_proc(ray,"+DrawTextureNPatch",{C_UINT,C_INT,C_INT,C_INT,C_INT,C_INT,C_UINT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawTexture(sequence seg,atom x,atom y,atom tint)

 c_proc(xDrawTexture,{seg[1],seg[2],seg[3],seg[4],seg[5],x,y,tint})
	
end procedure

public procedure DrawTextureV(sequence seg,atom x,atom y,atom tint)

 c_proc(xDrawTextureV,{seg[1],seg[2],seg[3],seg[4],seg[5],x,y,tint})
	
end procedure

public procedure DrawTextureEx(sequence seg,atom x,atom y,atom rot,atom scale,atom tint)

 c_proc(xDrawTextureEx,{seg[1],seg[2],seg[3],seg[4],seg[5],x,y,rot,scale,tint})
	
end procedure

public procedure DrawTextureRec(sequence seg,atom sx,atom sy,atom sw,atom sh,atom x,atom y,atom tint)

 c_proc(xDrawTextureRec,{seg[1],seg[2],seg[3],seg[4],seg[5],sx,sy,sw,sh,x,y,tint})
	
end procedure

public procedure DrawTextureQuad(sequence seg,atom x,atom y,atom x2,atom y2,atom qx,atom qy,atom qw,atom qh,atom tint)

 c_proc(xDrawTextureQuad,{seg[1],seg[2],seg[3],seg[4],seg[5],x,y,x2,y2,qx,qy,qw,qh,tint})
	
end procedure

public procedure DrawTexturePro(sequence seg,atom sx,atom sy,atom sw,atom sh,atom dx,atom dy,atom dw,atom dh,atom x,atom y,atom rot,atom tint)

 c_proc(xDrawTexturePro,{seg[1],seg[2],seg[3],seg[4],seg[5],sx,sy,sw,sh,dx,dy,dw,dh,x,y,rot,tint})
	
end procedure

public procedure DrawTextureNPatch(sequence seg,atom info,atom dx,atom dy,atom dw,atom dh,atom x,atom y,atom rot,atom tint)

 c_proc(xDrawTextureNPatch,{seg[1],seg[2],seg[3],seg[4],seg[5],info,dx,dy,dw,dh,x,y,rot,tint})
	
end procedure

public constant xDrawTextureTiled = define_c_proc(ray,"+DrawTextureTiled",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})

public procedure DrawTextureTiled(atom tex,atom rect,atom rect2,atom x,atom y,atom rot,atom sca,atom tint)

 c_proc(xDrawTextureTiled,{tex,rect,rect2,x,y,rot,sca,tint})
	
end procedure

public constant xUpdateTextureRec = define_c_proc(ray,"+UpdateTextureRec",{C_POINTER,C_POINTER,C_POINTER})

public procedure UpdateTextureRec(atom tex,atom rec,atom pix)

 c_proc(xUpdateTextureRec,{tex,rec,pix})
	
end procedure

public constant xUnloadImageColors = define_c_proc(ray,"+UnloadImageColors",{C_POINTER})

public procedure UnloadImageColors(atom col)

 c_proc(xUnloadImageColors,{col})
	
end procedure

--

public constant xImageClearBackground = define_c_proc(ray,"+ImageClearBackground",{C_POINTER,C_UINT}),
				xImageDrawPixel = define_c_proc(ray,"+ImageDrawPixel",{C_POINTER,C_INT,C_INT,C_UINT}),
				xImageDrawCircle = define_c_proc(ray,"+ImageDrawCircle",{C_POINTER,C_INT,C_INT,C_INT,C_UINT}),
				xImageDrawPixelV = define_c_proc(ray,"+ImageDrawPixelV",{C_POINTER,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawCircleV = define_c_proc(ray,"+ImageDrawCircleV",{C_POINTER,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xImageDrawLineV = define_c_proc(ray,"+ImageDrawLineV",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawRectangleV = define_c_proc(ray,"+ImageDrawRectangleV",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xImageDrawRectangleRec = define_c_proc(ray,"+ImageDrawRectangleRec",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})

public procedure ImageClearBackground(atom img,atom col)

 c_proc(xImageClearBackground,{img,col})
	
end procedure

public procedure ImageDrawPixel(atom img,atom x,atom y,atom col)

 c_proc(xImageDrawPixel,{img,x,y,col})
	
end procedure

public procedure ImageDrawCircle(atom img,atom x,atom y,atom rad,atom col)

 c_proc(xImageDrawCircle,{img,x,y,rad,col})
	
end procedure

public procedure ImageDrawPixelV(atom img,atom x,atom y,atom col)

 c_proc(xImageDrawPixelV,{img,x,y,col})
	
end procedure

public procedure ImageDrawCircleV(atom img,atom x,atom y,atom rad,atom col)

 c_proc(xImageDrawCircleV,{img,x,y,rad,col})
	
end procedure

public procedure ImageDrawLineV(atom img,atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xImageDrawLineV,{img,x,y,x2,y2,col})
	
end procedure

public procedure ImageDrawRectangleV(atom img,atom x,atom y,atom x2,atom y2,atom col)

 c_proc(xImageDrawRectangleV,{img,x,y,x2,y2,col})
	
end procedure

public procedure ImageDrawRectangleRec(atom img,atom x,atom y,atom w,atom h,atom col)

 c_proc(xImageDrawRectangleRec,{img,x,y,w,h,col})
	
end procedure

--End Texture Module

--Text Module Functions

public constant xGetFontDefault = define_c_func(ray,"+GetFontDefault",{},C_POINTER),
				xLoadFont = define_c_func(ray,"+LoadFont",{C_POINTER},C_POINTER),
				xLoadFontEx = define_c_func(ray,"+LoadFontEx",{C_POINTER,C_INT,C_POINTER,C_INT},C_POINTER),
				xLoadFontFromImage = define_c_func(ray,"+LoadFontFromImage",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xLoadFontData = define_c_func(ray,"+LoadFontData",{C_POINTER,C_INT,C_POINTER,C_INT,C_INT},C_POINTER),
				xGenImageFontAtlas = define_c_func(ray,"+GenImageFontAtlas",{C_POINTER,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xUnloadFont = define_c_proc(ray,"+UnloadFont",{C_POINTER}),
				xLoadFontFromMemory = define_c_func(ray,"+LoadFontFromMemory",{C_POINTER,C_POINTER,C_INT,C_INT,C_POINTER,C_INT},C_POINTER),
				xUnloadFontData = define_c_proc(ray,"+UnloadFontData",{C_POINTER,C_INT})
				
public function GetFontDefault()

 return c_func(xGetFontDefault,{})
	
end function

public function LoadFont(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFont,{str})
	
end function

public function LoadFontEx(sequence file,atom size,atom chars,atom count)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFontEx,{str,size,chars,count})
	
end function

public function LoadFontFromImage(atom img,atom xkey,atom char)

 return c_func(xLoadFontFromImage,{img,xkey,char})
	
end function

public function LoadFontData(sequence file,atom size,atom chars,atom count,atom xtype)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadFontData,{str,size,chars,count,xtype})
	
end function

public function GenImageFontAtlas(atom chars,atom count,atom size,atom pad,atom method)

 return c_func(xGenImageFontAtlas,{chars,count,size,pad,method})
	
end function

public procedure UnloadFont(atom font)

 c_proc(xUnloadFont,{font})
	
end procedure

public function LoadFontFromMemory(sequence file,sequence dat,atom size,atom fsize,atom fchar,atom count)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(dat,1)
 
 return c_func(xLoadFontFromMemory,{str,str2,size,fsize,fchar,count})
	
end function

public procedure UnloadFontData(atom font,atom c)

 c_proc(xUnloadFontData,{font,c})
	
end procedure

--Text Drawing

public constant xDrawFPS = define_c_proc(ray,"+DrawFPS",{C_INT,C_INT}),
				xDrawText = define_c_proc(ray,"+DrawText",{C_POINTER,C_INT,C_INT,C_INT,C_UINT}),
				xDrawTextEx = define_c_proc(ray,"+DrawTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawTextRec = define_c_proc(ray,"+DrawTextRec",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_BOOL,C_UINT}),
				xDrawTextRecEx = define_c_proc(ray,"+DrawTextRecEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_BOOL,C_UINT,C_INT,C_INT,C_UINT,C_UINT})
				
public procedure DrawFPS(atom x,atom y)

 c_proc(xDrawFPS,{x,y})
	
end procedure

public procedure DrawText(sequence text,atom x,atom y,atom size,atom col)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawText,{str,x,y,size,col})
	
end procedure

public procedure DrawTextEx(atom font,sequence text,atom x,atom y,atom size,atom space,atom tint)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawTextEx,{font,str,x,y,size,space,tint})
	
end procedure

public procedure DrawTextRec(atom font,sequence text,atom x,atom y,atom w,atom h,atom size,atom space,atom xwrap,atom tint)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawTextRec,{font,str,x,y,w,h,size,space,xwrap,tint})
	
end procedure

public procedure DrawTextRecEx(atom font,sequence text,atom x,atom y,atom w,atom h,atom size,atom space,atom xwrap,atom tint,atom start,atom xlength,atom tex,atom back)

 atom str = allocate_string(text,1)
 
 c_proc(xDrawTextRecEx,{font,str,x,y,w,h,size,space,xwrap,tint,start,xlength,tex,back})
	
end procedure

--Text Misc

public constant xMeasureText = define_c_func(ray,"+MeasureText",{C_POINTER,C_INT},C_INT),
				xMeasureTextEx = define_c_func(ray,"+MeasureTextEx",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT},C_FLOAT),
				xGetGlyphIndex = define_c_func(ray,"+GetGlyphIndex",{C_POINTER,C_INT},C_INT)
				
public function MeasureText(sequence text,atom size)

 atom str = allocate_string(text,1)
 
 return c_func(xMeasureText,{str,size})
	
end function

public function MeasureTextEx(atom font,sequence text,atom size,atom space)

 atom str = allocate_string(text,1)
 
 return c_func(xMeasureTextEx,{font,str,size,space})
	
end function

public function GetGlyphIndex(atom font,atom char)

 return c_func(xGetGlyphIndex,{font,char})
	
end function

--Text String Management

public constant xTextIsEqual = define_c_func(ray,"+TextIsEqual",{C_POINTER,C_POINTER},C_BOOL),
				xTextLength = define_c_func(ray,"+TextLength",{C_POINTER},C_UINT),
				xTextFormat = define_c_func(ray,"+TextFormat",{C_POINTER},C_POINTER),
				xTextSubtext = define_c_func(ray,"+TextSubtext",{C_POINTER,C_INT,C_INT},C_POINTER),
				xTextReplace = define_c_func(ray,"+TextReplace",{C_POINTER,C_POINTER,C_POINTER},C_POINTER),
				xTextInsert = define_c_func(ray,"+TextInsert",{C_POINTER,C_POINTER,C_INT},C_POINTER),
				xTextJoin = define_c_func(ray,"+TextJoin",{C_POINTER,C_INT,C_POINTER},C_POINTER),
				xTextSplit = define_c_func(ray,"+TextSplit",{C_POINTER,C_CHAR,C_POINTER},C_POINTER),
				xTextAppend = define_c_proc(ray,"+TextAppend",{C_POINTER,C_POINTER,C_POINTER}),
				xTextFindIndex = define_c_func(ray,"+TextFindIndex",{C_POINTER,C_POINTER},C_INT),
				xTextToUpper = define_c_func(ray,"+TextToUpper",{C_POINTER},C_POINTER),
				xTextToLower = define_c_func(ray,"+TextToLower",{C_POINTER},C_POINTER),
				xTextToPascal = define_c_func(ray,"+TextToPascal",{C_POINTER},C_POINTER),
				xTextToInteger = define_c_func(ray,"+TextToInteger",{C_POINTER},C_INT)
				
public function TextIsEqual(sequence text,sequence text2)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(text2,1)
 
 return c_func(xTextIsEqual,{str,str2})
	
end function

public function TextLength(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextLength,{str})
	
end function

public function TextFormat(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextFormat,{str})
	
end function

public function TextSubtext(sequence text,atom pos,atom xlen)

 atom str = allocate_string(text,1)
 
 return c_func(xTextSubtext,{str,pos,xlen})
	
end function

public function TextReplace(sequence text,sequence rep,sequence xby)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(rep,1)
 atom str3 = allocate_string(xby,1)
 
 return c_func(xTextReplace,{str,str2,str3})
	
end function

public function TextInsert(sequence text,sequence in,atom pos)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(in,1)
 
 return c_func(xTextInsert,{str,str2,pos})
	
end function

public function TextJoin(sequence text,atom count,sequence del)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(del,1)
 
 return c_func(xTextJoin,{str,count,str2})
	
end function

public function TextSplit(sequence text,sequence char,atom count)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(char,1)
 
 return c_func(xTextSplit,{str,str2,count})
	
end function

public procedure TextAppend(sequence text,sequence app,atom pos)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(app,1)
 
 c_proc(xTextAppend,{str,str2,pos})
	
end procedure

public function TextFindIndex(sequence text,sequence fin)

 atom str = allocate_string(text,1)
 atom str2 = allocate_string(fin,1)
 
 return c_func(xTextFindIndex,{str,str2})
	
end function

public function TextToUpper(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextToUpper,{str})
	
end function

public function TextToLower(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextToLower,{str})
	
end function

public function TextToPascal(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextToPascal,{str})
	
end function

public function TextToInteger(sequence text)

 atom str = allocate_string(text,1)
 
 return c_func(xTextToInteger,{str})
	
end function

public constant xTextCopy = define_c_func(ray,"+TextCopy",{C_POINTER,C_POINTER},C_INT)

public function TextCopy(sequence dst,sequence src)

 atom str = allocate_string(dst,1)
 atom str2 = allocate_string(src,1)
 
 return c_func(xTextCopy,{str,str2})
	
end function

public constant xGetCodepoints = define_c_func(ray,"+GetCodepoints",{C_POINTER,C_POINTER},C_POINTER),
				xCodepointToUtf8 = define_c_func(ray,"+CodepointToUtf8",{C_INT,C_POINTER},C_POINTER)
				
public function GetCodepoints(sequence txt,atom cnt)

 atom str = allocate_string(txt,1)
 
 return c_func(xGetCodepoints,{str,cnt})
	
end function

public function CodepointToUtf8(atom pt,atom len)

 return c_func(xCodepointToUtf8,{pt,len})
	
end function

--

public constant xDrawTextCodepoint = define_c_proc(ray,"+DrawTextCodepoint",{C_POINTER,C_INT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})

public procedure DrawTextCodepoint(atom font,atom pt,atom x,atom y,atom scale,atom col)

 c_proc(xDrawTextCodepoint,{font,pt,x,y,scale,col})
	
end procedure

--End Module Text

--Model Module Functions

public constant xDrawLine3D = define_c_proc(ray,"+DrawLine3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCircle3D = define_c_proc(ray,"+DrawCircle3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCube = define_c_proc(ray,"+DrawCube",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeV = define_c_proc(ray,"+DrawCubeV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeWires = define_c_proc(ray,"+DrawCubeWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawCubeTexture = define_c_proc(ray,"+DrawCubeTexture",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawSphere = define_c_proc(ray,"+DrawSphere",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawSphereEx = define_c_proc(ray,"+DrawSphereEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_UINT}),
				xDrawSphereWires = define_c_proc(ray,"+DrawSphereWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_INT,C_UINT}),
				xDrawCylinder = define_c_proc(ray,"+DrawCylinder",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawCylinderWires = define_c_proc(ray,"+DrawCylinderWires",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_INT,C_UINT}),
				xDrawPlane = define_c_proc(ray,"+DrawPlane",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawRay = define_c_proc(ray,"+DrawRay",{C_POINTER,C_UINT}),
				xDrawGrid = define_c_proc(ray,"+DrawGrid",{C_INT,C_FLOAT}),
				xDrawGizmo = define_c_proc(ray,"+DrawGizmo",{C_FLOAT,C_FLOAT,C_FLOAT}),
				xDrawCubeWiresV = define_c_proc(ray,"+DrawCubeWiresV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawLine3D(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawLine3D,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawCircle3D(atom x,atom y,atom z,atom rad,atom x2,atom y2,atom z2,atom rot,atom col)

 c_proc(xDrawCircle3D,{x,y,z,rad,x2,y2,z2,rot,col})
	
end procedure

public procedure DrawCube(atom x,atom y,atom z,atom w,atom h,atom len,atom col)

 c_proc(xDrawCube,{x,y,z,w,h,len,col})
	
end procedure

public procedure DrawCubeV(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawCubeV,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawCubeWires(atom x,atom y,atom z,atom w,atom h,atom len,atom col)

 c_proc(xDrawCubeWires,{x,y,z,w,h,len,col})
	
end procedure

public procedure DrawCubeWiresV(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawCubeWiresV,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawCubeTexture(atom tex,atom x,atom y,atom z,atom w,atom h,atom len,atom col)

 c_proc(xDrawCubeTexture,{tex,x,y,z,w,h,len,col})
	
end procedure

public procedure DrawSphere(atom x,atom y,atom z,atom rad,atom col)

 c_proc(xDrawSphere,{x,y,z,rad,col})
	
end procedure

public procedure DrawSphereEx(atom x,atom y,atom z,atom rad,atom rings,atom slices,atom col)

 c_proc(xDrawSphereEx,{x,y,z,rad,rings,slices,col})
	
end procedure

public procedure DrawSphereWires(atom x,atom y,atom z,atom rad,atom rings,atom slices,atom col)

 c_proc(xDrawSphereWires,{x,y,z,rad,rings,slices,col})
	
end procedure

public procedure DrawCylinder(atom x,atom y,atom z,atom rad,atom rad_bot,atom h,atom slices,atom col)

 c_proc(xDrawCylinder,{x,y,z,rad,rad_bot,h,slices,col})
	
end procedure

public procedure DrawCylinderWires(atom x,atom y,atom z,atom rad,atom rad_bot,atom h,atom slice,atom col)

 c_proc(xDrawCylinderWires,{x,y,z,rad,rad_bot,slice,col})
	
end procedure

public procedure DrawPlane(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawPlane,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawRay(atom ray,atom col)

 c_proc(xDrawRay,{ray,col})
	
end procedure

public procedure DrawGrid(atom slice,atom space)

 c_proc(xDrawGrid,{slice,space})
	
end procedure

public procedure DrawGizmo(atom x,atom y,atom z)

 c_proc(xDrawGizmo,{x,y,z})
	
end procedure

public constant xDrawTriangle3D = define_c_proc(ray,"+DrawTriangle3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})

public procedure DrawTriangle3D(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3,atom col)

 c_proc(xDrawTriangle3D,{x,y,z,x2,y2,z2,x3,y3,z3,col})
	
end procedure

--

public constant xDrawPoint3D = define_c_proc(ray,"+DrawPoint3D",{C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})

public procedure DrawPoint3D(atom x,atom y,atom z,atom col)

 c_proc(xDrawPoint3D,{x,y,z,col})
	
end procedure

--Model loading

public constant xLoadModel = define_c_func(ray,"+LoadModel",{C_POINTER},C_POINTER),
				xLoadModelFromMesh = define_c_func(ray,"+LoadModelFromMesh",{C_POINTER},C_POINTER),
				xUnloadModel = define_c_proc(ray,"+UnloadModel",{C_POINTER}),
				xUnloadModelKeepMeshes = define_c_proc(ray,"+UnloadModelKeepMeshes",{C_POINTER})
				
public function LoadModel(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadModel,{str})
	
end function

public function LoadModelFromMesh(atom mesh)

 return c_func(xLoadModelFromMesh,{mesh})
	
end function

public procedure UnloadModel(atom mod)

 c_proc(xUnloadModel,{mod})
	
end procedure

public procedure UnloadModelKeepMeshes(atom mod)

 c_proc(xUnloadModelKeepMeshes,{mod})
	
end procedure

--Mesh loading

public constant xLoadMeshes = define_c_func(ray,"+LoadMeshes",{C_POINTER,C_POINTER},C_POINTER),
				xExportMesh = define_c_proc(ray,"+ExportMesh",{C_POINTER,C_POINTER}),
				xUnloadMesh = define_c_proc(ray,"+UnloadMesh",{C_POINTER})
				
public function LoadMeshes(sequence file,atom count)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMeshes,{str,count})
	
end function

public procedure ExportMesh(atom mesh,sequence file)

 atom str = allocate_string(file,1)
 
 c_proc(xExportMesh,{mesh,str})
	
end procedure

public procedure UnloadMesh(atom mesh)

 c_proc(xUnloadMesh,{mesh})
	
end procedure

--Material Loading

public constant xLoadMaterials = define_c_func(ray,"+LoadMaterials",{C_POINTER,C_POINTER},C_POINTER),
				xLoadMaterialDefault = define_c_func(ray,"+LoadMaterialDefault",{},C_POINTER),
				xUnloadMaterial = define_c_proc(ray,"+UnloadMaterial",{C_POINTER}),
				xSetMaterialTexture = define_c_proc(ray,"+SetMaterialTexture",{C_POINTER,C_INT,C_POINTER}),
				xSetModelMeshMaterial = define_c_proc(ray,"+SetModelMeshMaterial",{C_POINTER,C_INT,C_INT})
				
public function LoadMaterials(sequence file,atom count)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMaterials,{str,count})
	
end function

public function LoadMaterialDefault()

 return c_func(xLoadMaterialDefault,{})
	
end function

public procedure UnloadMaterial(atom mat)

 c_proc(xUnloadMaterial,{mat})
	
end procedure

public procedure SetMaterialTexture(atom mat,atom xtype,atom tex)

 c_proc(xSetMaterialTexture,{mat,xtype,tex})
	
end procedure

public procedure SetModelMeshMaterial(atom mod,atom id,atom mat_id)

 c_proc(xSetModelMeshMaterial,{mod,id,mat_id})
	
end procedure

--Model animations

public constant xLoadModelAnimations = define_c_func(ray,"+LoadModelAnimations",{C_POINTER,C_POINTER},C_POINTER),
				xUpdateModelAnimation = define_c_proc(ray,"+UpdateModelAnimation",{C_POINTER,C_POINTER,C_INT}),
				xUnloadModelAnimation = define_c_proc(ray,"+UnloadModelAnimation",{C_POINTER}),
				xIsModelAnimationValid = define_c_func(ray,"+IsModelAnimationValid",{C_POINTER,C_POINTER},C_BOOL)
				
public function LoadModelAnimations(sequence file,atom count)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadModelAnimations,{str,count})
	
end function

public procedure UpdateModelAnimation(atom mod,atom ani,integer frame)

 c_proc(xUpdateModelAnimation,{mod,ani,frame})
	
end procedure

public procedure UnloadModelAnimation(atom anim)

 c_proc(xUnloadModelAnimation,{anim})
	
end procedure

public function IsModelAnimationValid(atom mod,atom ani)

 return c_func(xIsModelAnimationValid,{mod,ani})
	
end function

--Mesh generation

public constant xGenMeshPoly = define_c_func(ray,"+GenMeshPoly",{C_INT,C_FLOAT},C_POINTER),
				xGenMeshPlane = define_c_func(ray,"+GenMeshPlane",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshCube = define_c_func(ray,"+GenMeshCube",{C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGenMeshSphere = define_c_func(ray,"+GenMeshSphere",{C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshHemiSphere = define_c_func(ray,"+GenMeshHemiSphere",{C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshCylinder = define_c_func(ray,"+GenMeshCylinder",{C_FLOAT,C_FLOAT,C_INT},C_POINTER),
				xGenMeshTorus = define_c_func(ray,"+GenMeshTorus",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshKnot = define_c_func(ray,"+GenMeshKnot",{C_FLOAT,C_FLOAT,C_INT,C_INT},C_POINTER),
				xGenMeshHeightmap = define_c_func(ray,"+GenMeshHeightmap",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGenMeshCubicmap = define_c_func(ray,"+GenMeshCubicmap",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)
				
public function GenMeshPoly(atom sides,atom rad)

 return c_func(xGenMeshPoly,{sides,rad})
	
end function

public function GenMeshPlane(atom w,atom len,atom x,atom z)

 return c_func(xGenMeshPlane,{w,len,x,z})
	
end function

public function GenMeshCube(atom w,atom h,atom len)

 return c_func(xGenMeshCube,{w,h,len})
	
end function

public function GenMeshSphere(atom rad,atom rings,atom slice)

 return c_func(xGenMeshSphere,{rad,rings,slice})
	
end function

public function GenMeshHemiSphere(atom rad,atom rings,atom slice)

 return c_func(xGenMeshHemiSphere,{rad,rings,slice})
	
end function

public function GenMeshCylinder(atom rad,atom h,atom slice)

 return c_func(xGenMeshCylinder,{rad,h,slice})
	
end function

public function GenMeshTorus(atom rad,atom size,atom seg,atom side)

 return c_func(xGenMeshTorus,{rad,size,seg,side})
	
end function

public function GenMeshKnot(atom rad,atom size,atom seg,atom side)

 return c_func(xGenMeshKnot,{rad,size,seg,side})
	
end function

public function GenMeshHeightmap(atom cmap,atom x,atom y,atom z)

 return c_func(xGenMeshHeightmap,{cmap,x,y,z})
	
end function

public function GenMeshCubicmap(atom xmap,atom x,atom y,atom z)

 return c_func(xGenMeshCubicmap,{xmap,x,y,z})
	
end function

--Mesh manipulation

public constant xMeshBoundingBox = define_c_func(ray,"+MeshBoundingBox",{C_POINTER},C_POINTER),
				xMeshTangents = define_c_proc(ray,"+MeshTangents",{C_POINTER}),
				xMeshBinormals = define_c_proc(ray,"+MeshBinormals",{C_POINTER})
				
public function MeshBoundingBox(atom mesh)

 return c_func(xMeshBoundingBox,{mesh})
	
end function

public procedure MeshTangents(atom mesh)

 c_proc(xMeshTangents,{mesh})
	
end procedure

public procedure MeshBinormals(atom mesh)

 c_proc(xMeshBinormals,{mesh})
	
end procedure

--Model drawing

public constant xDrawModel = define_c_proc(ray,"+DrawModel",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelEx = define_c_proc(ray,"+DrawModelEx",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelWires = define_c_proc(ray,"+DrawModelWires",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawModelWiresEx = define_c_proc(ray,"+DrawModelWiresEx",{C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBoundingBox = define_c_proc(ray,"+DrawBoundingBox",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBillboard = define_c_proc(ray,"+DrawBillboard",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT}),
				xDrawBillboardRec = define_c_proc(ray,"+DrawBillboardRec",{C_POINTER,C_POINTER,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_UINT})
				
public procedure DrawModel(atom mod,atom x,atom y,atom z,atom scale,atom tint)

 c_proc(xDrawModel,{mod,x,y,z,scale,tint})
	
end procedure

public procedure DrawModelEx(atom mod,atom x,atom y,atom z,atom x2,atom y2,atom z2,atom rot,atom x3,atom y3,atom z3,atom tint)

 c_proc(xDrawModelEx,{mod,x,y,z,x2,y2,z2,rot,x3,y3,z3,tint})
	
end procedure

public procedure DrawModelWires(atom mod,atom x,atom y,atom z,atom scale,atom tint)

 c_proc(xDrawModelWires,{mod,x,y,z,scale,tint})
	
end procedure

public procedure DrawModelWiresEx(atom mod,atom x,atom y,atom z,atom x2,atom y2,atom z2,atom rot,atom x3,atom y3,atom z3,atom tint)

 c_proc(xDrawModelWiresEx,{mod,x,y,z,x2,y2,z2,rot,x3,y3,z3,tint})
	
end procedure

public procedure DrawBoundingBox(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom col)

 c_proc(xDrawBoundingBox,{x,y,z,x2,y2,z2,col})
	
end procedure

public procedure DrawBillboard(atom cam,atom tex,atom x,atom y,atom z,atom size,atom tint)

 c_proc(xDrawBillboard,{cam,tex,x,y,z,size,tint})
	
end procedure

public procedure DrawBillboardRec(atom cam,atom tex,atom sx,atom sy,atom sw,atom sh,atom x,atom y,atom z,atom size,atom tint)

 c_proc(xDrawBillboardRec,{cam,tex,sx,sy,sw,sh,x,y,z,size,tint})
	
end procedure

--Collision detection

public constant xCheckCollisionSpheres = define_c_func(ray,"+CheckCollisionSpheres",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionBoxes = define_c_func(ray,"+CheckCollisionBoxes",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionBoxSphere = define_c_func(ray,"+CheckCollisionBoxSphere",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xCheckCollisionRaySphere = define_c_func(ray,"+CheckCollisionRaySphere",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER,C_POINTER},C_BOOL),
				xCheckCollisionRayBox = define_c_func(ray,"+CheckCollisionRayBox",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL),
				xGetCollisionRayModel = define_c_func(ray,"+GetCollisionRayModel",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER},C_POINTER),
				xGetCollisionRayTriangle = define_c_func(ray,"+GetCollisionRayTriangle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xGetCollisionRayGround = define_c_func(ray,"+GetCollisionRayGround",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER),
				xCheckCollisionRaySphereEx = define_c_func(ray,"+CheckCollisionRaySphereEx",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_BOOL)
				
public function CheckCollisionSpheres(atom x,atom y,atom z,atom rad,atom x2,atom y2,atom z2,atom rad2)

 return c_func(xCheckCollisionSpheres,{x,y,z,rad,x2,y2,z2,rad2})
	
end function

public function CheckCollisionBoxes(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3,atom x4,atom y4,atom z4)

 return c_func(xCheckCollisionBoxes,{x,y,z,x2,y2,z3,x3,y3,z3,x4,y4,z4})
	
end function

public function CheckCollisionBoxSphere(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3,atom rad)

 return c_func(xCheckCollisionBoxSphere,{x,y,z,x2,y2,z2,x3,y3,z3,rad})
	
end function

public function CheckCollisionRaySphere(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom x,atom y,atom z,atom rad)

 return c_func(xCheckCollisionRaySphere,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,x,y,z,rad})
	
end function

public function CheckCollisionRaySphereEx(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom x,atom y,atom z,atom rad,atom x2,atom y2,atom z2)

 return c_func(xCheckCollisionRaySphereEx,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,x,y,z,rad,x2,y2,z2})
	
end function

public function CheckCollisionRayBox(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xCheckCollisionRayBox,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,x,y,z,x2,y2,z2})
	
end function

public function GetCollisionRayModel(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom mod)

 return c_func(xGetCollisionRayModel,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,mod})
	
end function

public function GetCollisionRayTriangle(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom x,atom y,atom z,atom x2,atom y2,atom z2,atom x3,atom y3,atom z3)

 return c_func(xGetCollisionRayTriangle,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,x,y,z,x2,y2,z2,x3,y3,z3})
	
end function

public function GetCollisionRayGround(atom ray_x,atom ray_y,atom ray_z,atom dir_x,atom dir_y,atom dir_z,atom height)

 return c_func(xGetCollisionRayGround,{ray_x,ray_y,ray_z,dir_x,dir_y,dir_z,height})
	
end function

--End Model Module

--Module Shader (rlgl)

public constant xLoadText = define_c_func(ray,"+LoadText",{C_POINTER},C_POINTER),
				xLoadShader = define_c_func(ray,"+LoadShader",{C_POINTER,C_POINTER},C_POINTER),
				xLoadShaderCode = define_c_func(ray,"+LoadShaderCode",{C_POINTER,C_POINTER},C_POINTER),
				xUnloadShader = define_c_proc(ray,"+UnloadShader",{C_POINTER})
				
public function LoadText(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadText,{str})
	
end function

public function LoadShader(sequence vsfile,sequence fsfile)

 atom str = allocate_string(vsfile,1)
 atom str2 = allocate_string(fsfile,1)
 
 return c_func(xLoadShader,{str,str2})
	
end function

public function LoadShaderCode(sequence vscode,sequence fscode)

 atom str = allocate_string(vscode,1)
 atom str2 = allocate_string(fscode,1)
 
 return c_func(xLoadShaderCode,{str,str2})
	
end function

public procedure UnloadShader(atom shade)

 c_proc(xUnloadShader,{shade})
	
end procedure

public constant xGetShaderDefault = define_c_func(ray,"+GetShaderDefault",{},C_POINTER),
				xGetTextureDefault = define_c_func(ray,"+GetTextureDefault",{},C_POINTER)
				
public function GetShaderDefault()

 return c_func(xGetShaderDefault,{})
	
end function

public function GetTextureDefault()

 return c_func(xGetTextureDefault,{})
	
end function

--Shader Config

public constant xGetShaderLocation = define_c_func(ray,"+GetShaderLocation",{C_POINTER,C_POINTER},C_INT),
				xSetShaderValue = define_c_proc(ray,"+SetShaderValue",{C_POINTER,C_INT,C_POINTER,C_INT}),
				xSetShaderValueV = define_c_proc(ray,"+SetShaderValueV",{C_POINTER,C_INT,C_POINTER,C_INT,C_INT}),
				xSetShaderValueMatrix = define_c_proc(ray,"+SetShaderValueMatrix",{C_POINTER,C_INT,C_POINTER}),
				xSetShaderValueTexture = define_c_proc(ray,"+SetShaderValueTexture",{C_POINTER,C_INT,C_POINTER}),
				xSetMatrixProjection = define_c_proc(ray,"+SetMatrixProjection",{C_POINTER}),
				xSetMatrixModelview = define_c_proc(ray,"+SetMatrixModelview",{C_POINTER}),
				xGetMatrixModelview = define_c_func(ray,"+GetMatrixModelview",{},C_POINTER),
				xGetMatrixProjection = define_c_func(ray,"+GetMatrixProjection",{},C_POINTER)
				
public function GetShaderLocation(atom shade,sequence name)

 atom str = allocate_string(name,1)
 
 return c_func(xGetShaderLocation,{shade,str})
	
end function

public procedure SetShaderValue(atom shade,atom loc,object val,atom xtype)

 
 c_proc(xSetShaderValue,{shade,loc,val,xtype})
	
end procedure

public procedure SetShaderValueV(atom shade,atom loc,object val,atom xtype,atom count)

 c_proc(xSetShaderValueV,{shade,loc,val,xtype,count})
	
end procedure

public procedure SetShaderValueMatrix(atom shade,atom loc,atom mat)

 c_proc(xSetShaderValueMatrix,{shade,loc,mat})
	
end procedure

public procedure SetShaderValueTexture(atom shade,atom loc,atom tex)

 c_proc(xSetShaderValueTexture,{shade,loc,tex})
	
end procedure

public procedure SetMatrixProjection(atom proj)

 c_proc(xSetMatrixProjection,{proj})
	
end procedure

public procedure SetMatrixModelview(atom view)

 c_proc(xSetMatrixModelview,{view})
	
end procedure

public function GetMatrixModelview()

 return c_func(xGetMatrixModelview,{})
	
end function

public function GetMatrixProjection()

 return c_func(xGetMatrixProjection,{})
	
end function

--shading begin/end

public constant xBeginShaderMode = define_c_proc(ray,"+BeginShaderMode",{C_POINTER}),
				xEndShaderMode = define_c_proc(ray,"+EndShaderMode",{}),
				xBeginBlendMode = define_c_proc(ray,"+BeginBlendMode",{C_INT}),
				xEndBlendMode = define_c_proc(ray,"+EndBlendMode",{}),
				xBeginScissorMode = define_c_proc(ray,"+BeginScissorMode",{C_INT,C_INT,C_INT,C_INT}),
				xEndScissorMode = define_c_proc(ray,"+EndScissorMode",{})
				
public procedure BeginShaderMode(atom shade)

 c_proc(xBeginShaderMode,{shade})
	
end procedure

public procedure EndShaderMode()

 c_proc(xEndShaderMode,{})
	
end procedure

public procedure BeginBlendMode(atom mode)

 c_proc(xBeginBlendMode,{mode})
	
end procedure

public procedure EndBlendMode()

 c_proc(xEndBlendMode,{})
	
end procedure

public procedure BeginScissorMode(atom x,atom y,atom w,atom h)

 c_proc(xBeginScissorMode,{x,y,w,h})
	
end procedure

public procedure EndScissorMode()

 c_proc(xEndScissorMode,{})
	
end procedure

--VR control

public constant xInitVrSimulator = define_c_proc(ray,"+InitVrSimulator",{}),
				xCloseVrSimulator = define_c_proc(ray,"+CloseVrSimulator",{}),
				xUpdateVrTracking = define_c_proc(ray,"+UpdateVrTracking",{C_POINTER}),
				xSetVrConfiguration = define_c_proc(ray,"+SetVrConfiguration",{C_POINTER,C_POINTER}),
				xIsVrSimulatorReady = define_c_proc(ray,"+IsVrSimulatorReady",{}),
				xToggleVrMode = define_c_proc(ray,"+ToggleVrMode",{}),
				xBeginVrDrawing = define_c_proc(ray,"+BeginVrDrawing",{}),
				xEndVrDrawing = define_c_proc(ray,"+EndVrDrawing",{})
				
public procedure InitVrSimulator()

 c_proc(xInitVrSimulator,{})
	
end procedure

public procedure CloseVrSimulator()

 c_proc(xCloseVrSimulator,{})
	
end procedure

public procedure UpdateVrTracking(atom cam)

 c_proc(xUpdateVrTracking,{cam})
	
end procedure

public procedure SetVrConfiguration(atom info,atom dist)

 c_proc(xSetVrConfiguration,{info,dist})
	
end procedure

public procedure IsVrSimulatorReady()

 c_proc(xIsVrSimulatorReady,{})
	
end procedure

public procedure ToggleVrMode()

 c_proc(xToggleVrMode,{})
	
end procedure

public procedure BeginVrDrawing()

 c_proc(xBeginVrDrawing,{})
	
end procedure

public procedure EndVrDrawing()

 c_proc(xEndVrDrawing,{})
	
end procedure

--End Shader Module

--Audio Module

public constant xInitAudioDevice = define_c_proc(ray,"+InitAudioDevice",{}),
				xCloseAudioDevice = define_c_proc(ray,"+CloseAudioDevice",{}),
				xIsAudioDeviceReady = define_c_func(ray,"+IsAudioDeviceReady",{},C_BOOL),
				xSetMasterVolume = define_c_proc(ray,"+SetMasterVolume",{C_FLOAT})
				
public procedure InitAudioDevice()

 c_proc(xInitAudioDevice,{})
	
end procedure

public procedure CloseAudioDevice()

 c_proc(xCloseAudioDevice,{})
	
end procedure

public function IsAudioDeviceReady()

 return c_func(xIsAudioDeviceReady,{})
	
end function

public procedure SetMasterVolume(atom vol)

 c_proc(xSetMasterVolume,{vol})
	
end procedure

--Wave sound load/unload

public constant xLoadWave = define_c_func(ray,"+LoadWave",{C_POINTER},C_POINTER),
				xLoadWaveEx = define_c_func(ray,"+LoadWaveEx",{C_POINTER,C_INT,C_INT,C_INT,C_INT},C_POINTER),
				xLoadSound = define_c_func(ray,"+LoadSound",{C_POINTER},C_POINTER),
				xLoadSoundFromWave = define_c_func(ray,"+LoadSoundFromWave",{C_POINTER},C_POINTER),
				xUpdateSound = define_c_proc(ray,"+UpdateSound",{C_POINTER,C_POINTER,C_INT}),
				xUnloadWave = define_c_proc(ray,"+UnloadWave",{C_POINTER}),
				xUnloadSound = define_c_proc(ray,"+UnloadSound",{C_POINTER}),
				xExportWave = define_c_proc(ray,"+ExportWave",{C_POINTER,C_POINTER}),
				xExportWaveAsCode = define_c_proc(ray,"+ExportWaveAsCode",{C_POINTER,C_POINTER}),
				xLoadWaveFromMemory = define_c_func(ray,"+LoadWaveFromMemory",{C_POINTER,C_POINTER,C_INT},C_POINTER)
				
public function LoadWave(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadWave,{str})
	
end function

public function LoadWaveEx(object data,atom count,atom rate,atom size,atom chan)

 return c_func(xLoadWaveEx,{data,count,rate,size,chan})
	
end function

public function LoadSound(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadSound,{str})
	
end function

public function LoadSoundFromWave(atom wav)

 return c_func(xLoadSoundFromWave,{wav})
	
end function

public procedure UpdateSound(atom snd,object data,atom count)

 c_proc(xUpdateSound,{snd,data,count})
	
end procedure

public procedure UnloadWave(atom wav)

 c_proc(xUnloadWave,{wav})
	
end procedure

public procedure UnloadSound(atom snd)

 c_proc(xUnloadSound,{snd})
	
end procedure

public procedure ExportWave(atom wav,sequence file)

 atom str = allocate_string(file,1)
 
 c_proc(xExportWave,{wav,str})
	
end procedure

public procedure ExportWaveAsCode(atom wav,sequence file)

 atom str = allocate_string(file,1)
 
 c_proc(xExportWaveAsCode,{wav,str})
	
end procedure

public function LoadWaveFromMemory(sequence file,sequence dat,atom size)

 atom str = allocate_string(file,1)
 atom str2 = allocate_string(dat,1)
 
 return c_func(xLoadWaveFromMemory,{str,str2,size})
	
end function

--Wave sound management

public constant xPlaySound = define_c_proc(ray,"+PlaySound",{C_POINTER}),
				xPauseSound = define_c_proc(ray,"+PauseSound",{C_POINTER}),
				xResumeSound = define_c_proc(ray,"+ResumeSound",{C_POINTER}),
				xStopSound = define_c_proc(ray,"+StopSound",{C_POINTER}),
				xIsSoundPlaying = define_c_func(ray,"+IsSoundPlaying",{C_POINTER},C_BOOL),
				xSetSoundVolume = define_c_proc(ray,"+SetSoundVolume",{C_POINTER,C_FLOAT}),
				xSetSoundPitch = define_c_proc(ray,"+SetSoundPitch",{C_POINTER,C_FLOAT}),
				xWaveFormat = define_c_proc(ray,"+WaveFormat",{C_POINTER,C_INT,C_INT,C_INT}),
				xWaveCopy = define_c_func(ray,"+WaveCopy",{C_POINTER},C_POINTER),
				xWaveCrop = define_c_proc(ray,"+WaveCrop",{C_POINTER,C_INT,C_INT}),
				xGetWaveData = define_c_func(ray,"+GetWaveData",{C_POINTER},C_POINTER)
				
public procedure PlaySound(atom snd)

 c_proc(xPlaySound,{snd})
	
end procedure

public procedure PauseSound(atom snd)

 c_proc(xPauseSound,{snd})
	
end procedure

public procedure ResumeSound(atom snd)

 c_proc(xResumeSound,{snd})
	
end procedure

public procedure StopSound(atom snd)

 c_proc(xStopSound,{snd})
	
end procedure

public function IsSoundPlaying(atom snd)

 return c_func(xIsSoundPlaying,{snd})
	
end function

public procedure SetSoundVolume(atom snd,atom vol)

 c_proc(xSetSoundVolume,{snd,vol})
	
end procedure

public procedure SetSoundPitch(atom snd,atom pit)

 c_proc(xSetSoundPitch,{snd,pit})
	
end procedure

public procedure WaveFormat(atom wav,atom rate,atom size,atom chan)

 c_proc(xWaveFormat,{wav,rate,size,chan})
	
end procedure

public function WaveCopy(atom wav)

 return c_func(xWaveCopy,{wav})
	
end function

public procedure WaveCrop(atom wav,atom samp,atom samp2)

 c_proc(xWaveCrop,{wav,samp,samp2})
	
end procedure

public function GetWaveData(atom wav)

 return c_func(xGetWaveData,{wav})
	
end function

--Music management

public constant xLoadMusicStream = define_c_func(ray,"+LoadMusicStream",{C_POINTER},C_POINTER),
				xUnloadMusicStream = define_c_proc(ray,"+UnloadMusicStream",{C_POINTER}),
				xPlayMusicStream = define_c_proc(ray,"+PlayMusicStream",{C_POINTER}),
				xUpdateMusicStream = define_c_proc(ray,"+UpdateMusicStream",{C_POINTER}),
				xStopMusicStream = define_c_proc(ray,"+StopMusicStream",{C_POINTER}),
				xPauseMusicStream = define_c_proc(ray,"+PauseMusicStream",{C_POINTER}),
				xResumeMusicStream = define_c_proc(ray,"+ResumeMusicStream",{C_POINTER}),
				xIsMusicPlaying = define_c_func(ray,"+IsMusicPlaying",{C_POINTER},C_BOOL),
				xSetMusicVolume = define_c_proc(ray,"+SetMusicVolume",{C_POINTER,C_FLOAT}),
				xSetMusicPitch = define_c_proc(ray,"+SetMusicPitch",{C_POINTER,C_FLOAT}),
				xSetMusicLoopCount = define_c_proc(ray,"+SetMusicLoopCount",{C_POINTER,C_INT}),
				xGetMusicTimeLength = define_c_func(ray,"+GetMusicTimeLength",{C_POINTER},C_FLOAT),
				xGetMusicTimePlayed = define_c_func(ray,"+GetMusicTimePlayed",{C_POINTER},C_FLOAT)
				
public function LoadMusicStream(sequence file)

 atom str = allocate_string(file,1)
 
 return c_func(xLoadMusicStream,{str})
	
end function

public procedure UnloadMusicStream(atom mus)

 c_proc(xUnloadMusicStream,{mus})
	
end procedure

public procedure PlayMusicStream(atom mus)

 c_proc(xPlayMusicStream,{mus})
	
end procedure

public procedure UpdateMusicStream(atom mus)

 c_proc(xUpdateMusicStream,{mus})
	
end procedure

public procedure StopMusicStream(atom mus)

 c_proc(xStopMusicStream,{mus})
	
end procedure

public procedure PauseMusicStream(atom mus)

 c_proc(xPauseMusicStream,{mus})
	
end procedure

public procedure ResumeMusicStream(atom mus)

 c_proc(xResumeMusicStream,{mus})
	
end procedure

public function IsMusicPlaying(atom mus)

 return c_func(xIsMusicPlaying,{mus})
	
end function

public procedure SetMusicVolume(atom mus,atom vol)

 c_proc(xSetMusicVolume,{mus,vol})
	
end procedure

public procedure SetMusicPitch(atom mus,atom pit)

 c_proc(xSetMusicPitch,{mus,pit})
	
end procedure

public procedure SetMusicLoopCount(atom mus,atom count)

 c_proc(xSetMusicLoopCount,{mus,count})
	
end procedure

public function GetMusicTimeLength(atom mus)

 return c_func(xGetMusicTimeLength,{mus})
	
end function

public function GetMusicTimePlayed(atom mus)

 return c_func(xGetMusicTimePlayed,{mus})
	
end function

--Audiostream management

public constant xInitAudioStream = define_c_func(ray,"+InitAudioStream",{C_UINT,C_UINT,C_UINT},C_POINTER),
				xUpdateAudioStream = define_c_proc(ray,"+UpdateAudioStream",{C_POINTER,C_POINTER,C_INT}),
				xCloseAudioStream = define_c_proc(ray,"+CloseAudioStream",{C_POINTER}),
				xIsAudioBufferProcessed = define_c_func(ray,"+IsAudioBufferProcessed",{C_POINTER},C_BOOL),
				xPlayAudioStream = define_c_proc(ray,"+PlayAudioStream",{C_POINTER}),
				xPauseAudioStream = define_c_proc(ray,"+PauseAudioStream",{C_POINTER}),
				xResumeAudioStream = define_c_proc(ray,"+ResumeAudioStream",{C_POINTER}),
				xIsAudioStreamPlaying = define_c_func(ray,"+IsAudioStreamPlaying",{C_POINTER},C_BOOL),
				xStopAudioStream = define_c_proc(ray,"+StopAudioStream",{C_POINTER}),
				xSetAudioStreamVolume = define_c_proc(ray,"+SetAudioStreamVolume",{C_POINTER,C_FLOAT}),
				xSetAudioStreamPitch = define_c_proc(ray,"+SetAudioStreamPitch",{C_POINTER,C_FLOAT})
				
public function InitAudioStream(atom samp,atom size,atom chan)

 return c_func(xInitAudioStream,{samp,size,chan})
	
end function

public procedure UpdateAudioStream(atom st,object data,atom samp)

 c_proc(xUpdateAudioStream,{st,data,samp})
	
end procedure

public procedure CloseAudioStream(atom st)
 
 c_proc(xCloseAudioStream,{st})
	
end procedure

public function IsAudioBufferProcessed(atom st)

 return c_func(xIsAudioBufferProcessed,{st})
	
end function

public procedure PlayAudioStream(atom st)

 c_proc(xPlayAudioStream,{st})
	
end procedure

public procedure PauseAudioStream(atom st)
 
 c_proc(xPauseAudioStream,{st})
	
end procedure

public procedure ResumeAudioStream(atom st)

 c_proc(xResumeAudioStream,{st})
	
end procedure

public function IsAudioStreamPlaying(atom st)

 return c_func(xIsAudioStreamPlaying,{st})
	
end function

public procedure StopAudioStream(atom st)

 c_proc(xStopAudioStream,{st})
	
end procedure

public procedure SetAudioStreamVolume(atom st,atom vol)

 c_proc(xSetAudioStreamVolume,{st,vol})
	
end procedure

public procedure SetAudioStreamPitch(atom st,atom pit)

 c_proc(xSetAudioStreamPitch,{st,pit})
	
end procedure

--Math Functions

public constant xClamp = define_c_func(ray,"+Clamp",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Clamp(atom val,atom min,atom max)

 return c_func(xClamp,{val,min,max})
	
end function

public constant xLerp = define_c_func(ray,"+Lerp",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Lerp(atom start,atom xend,atom amount)

 return c_func(xLerp,{start,xend,amount})
	
end function

public constant xVector2Zero = define_c_func(ray,"+Vector2Zero",{},C_FLOAT)

public function Vector2Zero()

 return c_func(xVector2Zero,{})
	
end function

public constant xVector2One = define_c_func(ray,"+Vector2One",{},C_FLOAT)

public function Vector2One()

 return c_func(xVector2One,{})
	
end function

public constant xVector2Add = define_c_func(ray,"+Vector2Add",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Add(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2Add,{x,y,x2,y2})
	
end function

public constant xVector2Subtract = define_c_func(ray,"+Vector2Subtract",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Subtract(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2Subtract,{x,y,x2,y2})
	
end function

public constant xVector2Length = define_c_func(ray,"+Vector2Length",{C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Length(atom x,atom y)

 return c_func(xVector2Length,{x,y})
	
end function

public constant xVector2DotProduct = define_c_func(ray,"+Vector2DotProduct",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2DotProduct(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2DotProduct,{x,y,x2,y2})
	
end function

public constant xVector2Distance = define_c_func(ray,"+Vector2Distance",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Distance(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2Distance,{x,y,x2,y2})
	
end function

public constant xVector2Angle = define_c_func(ray,"+Vector2Angle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Angle(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2Angle,{x,y,x2,y2})
	
end function

public constant xVector2Scale = define_c_func(ray,"+Vector2Scale",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Scale(atom x,atom y,atom scale)

 return c_func(xVector2Scale,{x,y,scale})
	
end function

public constant xVector2Multiply = define_c_func(ray,"+Vector2Multiply",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Multiply(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2Multiply,{x,y,x2,y2})
	
end function

public constant xVector2Negate = define_c_func(ray,"+Vector2Negate",{C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Negate(atom x,atom y)

 return c_func(xVector2Negate,{x,y})
	
end function

public constant xVector2Divide = define_c_func(ray,"+Vector2Divide",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Divide(atom x,atom y,atom div)

 return c_func(xVector2Divide,{x,y,div})
	
end function

public constant xVector2DivideV = define_c_func(ray,"+Vector2DivideV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2DivideV(atom x,atom y,atom x2,atom y2)

 return c_func(xVector2DivideV,{x,y,x2,y2})
	
end function

public constant xVector2Normalize = define_c_func(ray,"+Vector2Normalize",{C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Normalize(atom x,atom y)

 return c_func(xVector2Normalize,{x,y})
	
end function

public constant xVector2Lerp = define_c_func(ray,"+Vector2Lerp",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector2Lerp(atom x,atom y,atom x2,atom y2,atom amount)

 return c_func(xVector2Lerp,{x,y,x2,y2,amount})
	
end function

public constant xVector3Zero = define_c_func(ray,"+Vector3Zero",{},C_FLOAT)

public function Vector3Zero()

 return c_func(xVector3Zero,{})
	
end function

public constant xVector3One = define_c_func(ray,"+Vector3One",{},C_FLOAT)

public function Vector3One()

 return c_func(xVector3One,{})
	
end function

public constant xVector3Add = define_c_func(ray,"+Vector3Add",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Add(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Add,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Subtract = define_c_func(ray,"+Vector3Subtract",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Subtract(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Subtract,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Multiply = define_c_func(ray,"+Vector3Multiply",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Multiply(atom x,atom y,atom z,atom scalar)

 return c_func(xVector3Multiply,{x,y,z,scalar})
	
end function

public constant xVector3MultiplyV = define_c_func(ray,"+Vector3MultiplyV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3MultiplyV(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3MultiplyV,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3CrossProduct = define_c_func(ray,"+Vector3CrossProduct",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3CrossProduct(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3CrossProduct,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Perpendicular = define_c_func(ray,"+Vector3Perpendicular",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Perpendicular(atom x,atom y,atom z)

 return c_func(xVector3Perpendicular,{x,y,z})
	
end function

public constant xVector3Length = define_c_func(ray,"+Vector3Length",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Length(atom x,atom y,atom z)

 return c_func(xVector3Length,{x,y,z})
	
end function

public constant xVector3DotProduct = define_c_func(ray,"+Vector3DotProduct",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3DotProduct(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3DotProduct,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Distance = define_c_func(ray,"+Vector3Distance",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Distance(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Distance,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Scale = define_c_func(ray,"+Vector3Scale",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Scale(atom x,atom y,atom z,atom scale)

 return c_func(xVector3Scale,{x,y,z,scale})
	
end function

public constant xVector3Negate = define_c_func(ray,"+Vector3Negate",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Negate(atom x,atom y,atom z)

 return c_func(xVector3Negate,{x,y,z})
	
end function

public constant xVector3Divide = define_c_func(ray,"+Vector3Divide",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Divide(atom x,atom y,atom z,atom div)

 return c_func(xVector3Divide,{x,y,z,div})
	
end function

public constant xVector3DivideV = define_c_func(ray,"+Vector3DivideV",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3DivideV(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3DivideV,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Normalize = define_c_func(ray,"+Vector3Normalize",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Normalize(atom x,atom y,atom z)

 return c_func(xVector3Normalize,{x,y,z})
	
end function

public constant xVector3OrthoNormalize = define_c_proc(ray,"+Vector3OrthoNormalize",{C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER,C_POINTER})

public procedure Vector3OrthoNormalize(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 c_proc(xVector3OrthoNormalize,{x,y,z,x2,y2,z2})
	
end procedure

public constant xVector3Transform = define_c_func(ray,"+Vector3Transform",{C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT)

public function Vector3Transform(atom x,atom y,atom z,sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xVector3Transform,{x,y,z,p_mat})
	
end function

public constant xVector3RotateByQuaternion = define_c_func(ray,"+Vector3RotateByQuaternion",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3RotateByQuaternion(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom w)

 return c_func(xVector3RotateByQuaternion,{x,y,z,x2,y2,z2,w})
	
end function

public constant xVector3Lerp = define_c_func(ray,"+Vector3Lerp",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Lerp(atom x,atom y,atom z,atom x2,atom y2,atom z2,atom amount)

 return c_func(xVector3Lerp,{x,y,z,x2,y2,z2,amount})
	
end function

public constant xVector3Reflect = define_c_func(ray,"+Vector3Reflect",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Reflect(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Reflect,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Min = define_c_func(ray,"+Vector3Min",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Min(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Min,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Max = define_c_func(ray,"+Vector3Max",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Max(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xVector3Max,{x,y,z,x2,y2,z2})
	
end function

public constant xVector3Barycenter = define_c_func(ray,"+Vector3Barycenter",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3Barycenter(atom px,atom py,atom pz,atom ax,atom ay,atom az,atom bx,atom By,atom bz,atom cx,atom cy,atom cz)

 return c_func(xVector3Barycenter,{px,py,pz,ax,ay,az,bx,By,bz,cx,cy,cz})
	
end function

public constant xVector3ToFloatV = define_c_func(ray,"+Vector3ToFloatV",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function Vector3ToFloatV(atom x,atom y,atom z)

 return c_func(xVector3ToFloatV,{x,y,z})
	
end function

public constant xMatrixDeterminant = define_c_func(ray,"+MatrixDeterminant",{C_POINTER},C_FLOAT)

public function MatrixDeterminant(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixDeterminant,{p_mat})
	
end function

public constant xMatrixTrace = define_c_func(ray,"+MatrixTrace",{C_POINTER},C_FLOAT)

public function MatrixTrace(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixTrace,{p_mat})
	
end function

public constant xMatrixTranspose = define_c_func(ray,"+MatrixTranspose",{C_POINTER},C_POINTER)

public function MatrixTranspose(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixTranspose,{p_mat})
	
end function

public constant xMatrixInvert = define_c_func(ray,"+MatrixInvert",{C_POINTER},C_POINTER)

public function MatrixInvert(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixInvert,{p_mat})
	
end function

public constant xMatrixNormalize = define_c_func(ray,"+MatrixNormalize",{C_POINTER},C_POINTER)

public function MatrixNormalize(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixNormalize,{p_mat})
	
end function

public constant xMatrixIdentity = define_c_func(ray,"+MatrixIdentity",{},C_POINTER)

public function MatrixIdentity()

 return c_func(xMatrixIdentity,{})
	
end function

public constant xMatrixAdd = define_c_func(ray,"+MatrixAdd",{C_POINTER,C_POINTER},C_POINTER)

public function MatrixAdd(sequence left,sequence right)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(left),1)
 atom p_mat2 = allocate_data(sizeof(C_FLOAT) * length(right),1)
 
 poke_float32(p_mat,left)
 poke_float32(p_mat2,right)
 
 return c_func(xMatrixAdd,{p_mat,p_mat2})
	
end function

public constant xMatrixSubtract = define_c_func(ray,"+MatrixSubtract",{C_POINTER,C_POINTER},C_POINTER)

public function MatrixSubtract(sequence left,sequence right)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(left),1)
 atom p_mat2 = allocate_data(sizeof(C_FLOAT) * length(right),1)
 
 poke_float32(p_mat,left)
 poke_float32(p_mat2,right)
 
 return c_func(xMatrixSubtract,{p_mat,p_mat2})
	
end function

public constant xMatrixTranslate = define_c_func(ray,"+MatrixTranslate",{C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)

public function MatrixTranslate(atom x,atom y,atom z)

 return c_func(xMatrixTranslate,{x,y,z})
	
end function

public constant xMatrixRotate = define_c_func(ray,"+MatrixRotate",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)

public function MatrixRotate(atom x,atom y,atom z,atom angle)

 return c_func(xMatrixRotate,{x,y,z,angle})
	
end function

public constant xMatrixRotateX = define_c_func(ray,"+MatrixRotateX",{C_FLOAT},C_POINTER)

public function MatrixRotateX(atom angle)

 return c_func(xMatrixRotateX,{angle})
	
end function

public constant xMatrixRotateY = define_c_func(ray,"+MatrixRotateY",{C_FLOAT},C_POINTER)

public function MatrixRotateY(atom angle)

 return c_func(xMatrixRotateY,{angle})
	
end function

public constant xMatrixRotateZ = define_c_func(ray,"+MatrixRotateZ",{C_FLOAT},C_POINTER)

public function MatrixRotateZ(atom angle)

 return c_func(xMatrixRotateZ,{angle})
	
end function

public constant xMatrixScale = define_c_func(ray,"+MatrixScale",{C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)

public function MatrixScale(atom x,atom y,atom z)

 return c_func(xMatrixScale,{x,y,z})
	
end function

public constant xMatrixMultiply = define_c_func(ray,"+MatrixMultiply",{C_POINTER,C_POINTER},C_POINTER)

public function MatrixMultiply(sequence left,sequence right)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(left),1)
 atom p_mat2 = allocate_data(sizeof(C_FLOAT) * length(right),1)
 
 poke_float32(p_mat,left)
 poke_float32(p_mat2,right)
 
 return c_func(xMatrixMultiply,{p_mat,p_mat2})
	
end function

public constant xMatrixFrustum = define_c_func(ray,"+MatrixFrustum",{C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE},C_POINTER)

public function MatrixFrustum(atom left,atom right,atom bot,atom top,atom near,atom far)

 return c_func(xMatrixFrustum,{left,right,bot,top,near,far})
	
end function

public constant xMatrixPerspective = define_c_func(ray,"+MatrixPerspective",{C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE},C_POINTER)

public function MatrixPerspective(atom fov,atom aspect,atom near,atom far)

 return c_func(xMatrixPerspective,{fov,aspect,near,far})
	
end function

public constant xMatrixOrtho = define_c_func(ray,"+MatrixOrtho",{C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE,C_DOUBLE},C_POINTER)

public function MatrixOrtho(atom left,atom right,atom bot,atom top,atom near,atom far)

 return c_func(xMatrixOrtho,{left,right,bot,top,near,far})
	
end function

public constant xMatrixLookAt = define_c_func(ray,"+MatrixLookAt",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_POINTER)

public function MatrixLookAt(atom x,atom y,atom z,atom tx,atom ty,atom tz,atom ux,atom uy,atom uz)

 return c_func(xMatrixLookAt,{x,y,z,tx,ty,tz,ux,uy,uz})
	
end function

public constant xMatrixToFloatV = define_c_func(ray,"+MatrixToFloatV",{C_POINTER},C_FLOAT)

public function MatrixToFloatV(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xMatrixToFloatV,{p_mat})
	
end function

public constant xQuaternionIdentity = define_c_func(ray,"+QuaternionIdentity",{},C_POINTER)

public function QuaternionIdentity()

 return c_func(xQuaternionIdentity,{})
	
end function

public constant xQuaternionLength = define_c_func(ray,"+QuaternionLength",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionLength(atom x,atom y,atom z,atom w)

 return c_func(xQuaternionLength,{x,y,z,w})
	
end function

public constant xQuaternionNormalize = define_c_func(ray,"+QuaternionNormalize",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionNormalize(atom x,atom y,atom z,atom w)

 return c_func(xQuaternionNormalize,{x,y,z,w})
	
end function

public constant xQuaternionInvert = define_c_func(ray,"+QuaternionInvert",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionInvert(atom x,atom y,atom z,atom w)

 return c_func(xQuaternionInvert,{x,y,z,w})
	
end function

public constant xQuaternionMultiply = define_c_func(ray,"+QuaternionMultiply",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionMultiply(atom x,atom y,atom z,atom w,atom x2,atom y2,atom z2,atom w2)

 return c_func(xQuaternionMultiply,{x,y,z,w,x2,y2,z2,w2})
	
end function

public constant xQuaternionLerp = define_c_func(ray,"+QuaternionLerp",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionLerp(atom x,atom y,atom z,atom w,atom x2,atom y2,atom z2,atom w2,atom amount)
	
 return c_func(xQuaternionLerp,{x,y,z,w,x2,y2,z2,w2})

end function

public constant xQuaternionNlerp = define_c_func(ray,"+QuaternionNlerp",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionNlerp(atom x,atom y,atom z,atom w,atom x2,atom y2,atom z2,atom w2,atom amount)

 return c_func(xQuaternionNlerp,{x,y,z,w,x2,y2,z2,w2,amount})
	
end function

public constant xQuaternionSlerp = define_c_func(ray,"+QuaternionSlerp",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionSlerp(atom x,atom y,atom z,atom w,atom x2,atom y2,atom z2,atom w2)

 return c_func(xQuaternionSlerp,{x,y,z,w,x2,y2,z2,w2})
	
end function

public constant xQuaternionFromVector3ToVector3 = define_c_func(ray,"+QuaternionFromVector3ToVector3",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionFromVector3ToVector3(atom x,atom y,atom z,atom x2,atom y2,atom z2)

 return c_func(xQuaternionFromVector3ToVector3,{x,y,z,x2,y2,z2})
	
end function

public constant xQuaternionFromMatrix = define_c_func(ray,"+QuaternionFromMatrix",{C_POINTER},C_FLOAT)

public function QuaternionFromMatrix(sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xQuaternionFromMatrix,{p_mat})
	
end function

public constant xQuaternionToMatrix = define_c_func(ray,"+QuaternionToMatrix",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionToMatrix(atom x,atom y,atom z,atom w)

 return c_func(xQuaternionToMatrix,{x,y,z,w})
	
end function

public constant xQuaternionFromAxisAngle = define_c_func(ray,"+QuaternionFromAxisAngle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionFromAxisAngle(atom x,atom y,atom z,atom angle)

 return c_func(xQuaternionFromAxisAngle,{x,y,z,angle})
	
end function

public constant xQuaternionToAxisAngle = define_c_proc(ray,"+QuaternionToAxisAngle",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER,C_POINTER,C_POINTER,C_POINTER})

public procedure QuaternionToAxisAngle(atom x,atom y,atom z,atom w,atom x2,atom y2,atom z2,atom angle)

 c_proc(xQuaternionToAxisAngle,{x,y,z,w,x2,y2,z2,angle})
	
end procedure

public constant xQuaternionFromEuler = define_c_func(ray,"+QuaternionFromEuler",{C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionFromEuler(atom roll,atom pitch,atom yaw)

 return c_func(xQuaternionFromEuler,{roll,pitch,yaw})
	
end function

public constant xQuaternionToEuler = define_c_func(ray,"+QuaternionToEuler",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT},C_FLOAT)

public function QuaternionToEuler(atom x,atom y,atom z,atom w)

 return c_func(xQuaternionToEuler,{x,y,z,w})
	
end function

public constant xQuaternionTransform = define_c_func(ray,"+QuaternionTransform",{C_FLOAT,C_FLOAT,C_FLOAT,C_FLOAT,C_POINTER},C_FLOAT)

public function QuaternionTransform(atom x,atom y,atom z,atom w,sequence mat)

 atom p_mat = allocate_data(sizeof(C_FLOAT) * length(mat),1)
 
 poke_float32(p_mat,mat)
 
 return c_func(xQuaternionTransform,{x,y,z,w,p_mat})
	
end function

--Shim Functions

--include std/dll.e
--include std/machine.e
include std/types.e

--
-- Vector2 type
--
public constant
	Vector2_x       =  0, -- float
	Vector2_y       =  4, -- float
	SIZEOF_VECTOR2  =  8,
$

public enum
	VECTOR2_X,
	VECTOR2_Y

constant C_VECTOR2 = {
	C_FLOAT, -- float x
	C_FLOAT  -- float y
}

--
-- Vector3 type
--
public constant
	Vector3_x       =  0, -- float
	Vector3_y       =  4, -- float
	Vector3_z       =  8, -- float
	SIZEOF_VECTOR3  = 12,
$

public enum
	VECTOR3_X,
	VECTOR3_Y,
	VECTOR3_Z

constant C_VECTOR3 = {
	C_FLOAT, -- float x
	C_FLOAT, -- float y
	C_FLOAT  -- float z
}

--
-- Vector4 type
--
public constant
	Vector4_x       =  0, -- float
	Vector4_y       =  4, -- float
	Vector4_z       =  8, -- float
	Vector4_w       = 12, -- float
	SIZEOF_VECTOR4  = 16,
$

public enum
	VECTOR4_X,
	VECTOR4_Y,
	VECTOR4_Z,
	VECTOR4_W

constant C_VECTOR4 = {
	C_FLOAT, -- float x
	C_FLOAT, -- float y
	C_FLOAT, -- float z
	C_FLOAT  -- float w
}

--
-- Quaternion type
-- same as Vector4
--
public constant
	Quaternion_x        = Vector4_x,
	Quaternion_y        = Vector4_y,
	Quaternion_z        = Vector4_z,
	Quaternion_w        = Vector4_w,
	SIZEOF_QUATERNION   = SIZEOF_VECTOR4,
$

public enum
	QUATERNION_X,
	QUATERNION_Y,
	QUATERNION_Z,
	QUATERNION_W

constant C_QUATERNION = C_VECTOR4

--
-- Matrix type
--
public constant
	Matrix_m0       =  0, -- float
	Matrix_m4       =  4, -- float
	Matrix_m8       =  8, -- float
	Matrix_m12      = 12, -- float
	Matrix_m1       = 16, -- float
	Matrix_m5       = 20, -- float
	Matrix_m9       = 24, -- float
	Matrix_m13      = 28, -- float
	Matrix_m2       = 32, -- float
	Matrix_m6       = 36, -- float
	Matrix_m10      = 40, -- float
	Matrix_m14      = 44, -- float
	Matrix_m3       = 48, -- float
	Matrix_m7       = 52, -- float
	Matrix_m11      = 56, -- float
	Matrix_m15      = 60, -- float
	SIZEOF_MATRIX   = 64,
$

public enum
	MATRIX_M0,
	MATRIX_M4,
	MATRIX_M8,
	MATRIX_M12,
	MATRIX_M1,
	MATRIX_M5,
	MATRIX_M9,
	MATRIX_M13,
	MATRIX_M2,
	MATRIX_M6,
	MATRIX_M10,
	MATRIX_M14,
	MATRIX_M3,
	MATRIX_M7,
	MATRIX_M11,
	MATRIX_M15

constant C_MATRIX = {
	C_FLOAT, -- float m0 
	C_FLOAT, -- float m4 
	C_FLOAT, -- float m8 
	C_FLOAT, -- float m12
	C_FLOAT, -- float m1 
	C_FLOAT, -- float m5 
	C_FLOAT, -- float m9 
	C_FLOAT, -- float m13
	C_FLOAT, -- float m2 
	C_FLOAT, -- float m6 
	C_FLOAT, -- float m10
	C_FLOAT, -- float m14
	C_FLOAT, -- float m3 
	C_FLOAT, -- float m7 
	C_FLOAT, -- float m11
	C_FLOAT  -- float m15
}

--
-- Color type
--
public constant
	Color_r         = 0, -- unsigned int
	Color_g         = 1, -- unsigned int
	Color_b         = 2, -- unsigned int
	Color_a         = 3, -- unsigned int
	SIZEOF_COLOR    = 4,
$

public enum
	COLOR_R,
	COLOR_G,
	COLOR_B,
	COLOR_A

constant C_COLOR = {
	C_UCHAR, -- unsigned char r
	C_UCHAR, -- unsigned char g
	C_UCHAR, -- unsigned char b
	C_UCHAR  -- unsigned char a
}

--
-- Rectangle type
--
public constant
	Rectangle_x         =  0, -- float
	Rectangle_y         =  4, -- float
	Rectangle_width     =  8, -- float
	Rectangle_height    = 12, -- float
	SIZEOF_RECTANGLE    = 16,
$

public enum
	RECTANGLE_X,
	RECTANGLE_Y,
	RECTANGLE_WIDTH,
	RECTANGLE_HEIGHT

constant C_RECTANGLE = {
	C_FLOAT, -- float x
	C_FLOAT, -- float y
	C_FLOAT, -- float width
	C_FLOAT  -- float height
}

--
-- Image type
--

ifdef BITS64 then

public constant
	Image_data      =  0, -- void*
	Image_width     =  8, -- int
	Image_height    = 12, -- int
	Image_mipmaps   = 16, -- int
	Image_format    = 20, -- int
	SIZEOF_IMAGE    = 24,
$

elsedef -- BITS32

public constant
	Image_data      =  0, -- void*
	Image_width     =  4, -- int
	Image_height    =  8, -- int
	Image_mipmaps   = 12, -- int
	Image_format    = 16, -- int
	SIZEOF_IMAGE    = 20,
$

end ifdef

public enum
	IMAGE_DATA,
	IMAGE_WIDTH,
	IMAGE_HEIGHT,
	IMAGE_MIPMAPS,
	IMAGE_FORMAT

constant C_IMAGE = {
	C_POINTER, -- void* data
	C_INT,     -- int width
	C_INT,     -- int height
	C_INT,     -- int mipmaps
	C_INT      -- int format
}

--
-- Texture2D type
--
public constant
	Texture2D_id        =  0, -- unsigned int
	Texture2D_width     =  4, -- int
	Texture2D_height    =  8, -- int
	Texture2D_mipmaps   = 12, -- int
	Texture2D_format    = 16, -- int
	SIZEOF_TEXTURE2D    = 20,
$

public enum
	TEXTURE2D_ID,
	TEXTURE2D_WIDTH,
	TEXTURE2D_HEIGHT,
	TEXTURE2D_MIPMAPS,
	TEXTURE2D_FORMAT

constant C_TEXTURE2D = {
	C_UINT, -- unsigned int id
	C_INT,  -- int width
	C_INT,  -- int height
	C_INT,  -- int mipmaps
	C_INT   -- int format
}

--
-- Texture type
-- same as Texture2D
--
public constant
	Texture_id      = Texture2D_id,
	Texture_width   = Texture2D_width,
	Texture_height  = Texture2D_height,
	Texture_mipmaps = Texture2D_mipmaps,
	Texture_format  = Texture2D_format,
	SIZEOF_TEXTURE  = SIZEOF_TEXTURE2D,
$

public enum
	TEXTURE_ID,
	TEXTURE_WIDTH,
	TEXTURE_HEIGHT,
	TEXTURE_MIPMAPS,
	TEXTURE_FORMAT

constant C_TEXTURE = C_TEXTURE2D

--
-- RenderTexture2D type
--
public constant
	RenderTexture2D_id           =  0, -- unsigned int
	RenderTexture2D_texture      =  4, -- Texture2D
	RenderTexture2D_depth        = 24, -- Texture2D
	RenderTexture2D_depthTexture = 44, -- bool
	SIZEOF_RENDERTEXTURE2D       = 48,
$

public enum
	RENDERTEXTURE2D_ID,
	RENDERTEXTURE2D_TEXTURE,
	RENDERTEXTURE2D_DEPTH,
	RENDERTEXTURE2D_DEPTHTEXTURE

constant C_RENDERTEXTURE2D =
	C_UINT      & -- unsigned int id
	C_TEXTURE2D & -- Texture2D texture
	C_TEXTURE2D & -- Texture2D depth
	C_BOOL        -- bool depthTexture

--
-- RenderTexture type
-- same as RenderTexture2D
--
public constant
	RenderTexture_id            = RenderTexture2D_id,
	RenderTexture_texture       = RenderTexture2D_texture,
	RenderTexture_depth         = RenderTexture2D_depth,
	RenderTexture_depthTexture  = RenderTexture2D_depthTexture,
	SIZEOF_RENDERTEXTURE        = SIZEOF_RENDERTEXTURE2D,
$

public enum
	RENDERTEXTURE_ID,
	RENDERTEXTURE_TEXTURE,
	RENDERTEXTURE_DEPTH,
	RENDERTEXTURE_DEPTHTEXTURE

constant C_RENDERTEXTURE = C_RENDERTEXTURE2D

--
-- N-Patch layout info
--
public constant
	NPatchInfo_sourceRec    =  0, -- Rectangle
	NPatchInfo_left         = 16, -- int
	NPatchInfo_top          = 16, -- int
	NPatchInfo_right        = 16, -- int
	NPatchInfo_bottom       = 16, -- int
	NPatchInfo_type         = 16, -- int
$

public enum
	NPATCHINFO_SOURCEREC,
	NPATCHINFO_LEFT,
	NPATCHINFO_TOP,
	NPATCHINFO_RIGHT,
	NPATCHINFO_BOTTOM,
	NPATCHINFO_TYPE

constant C_NPATCHINFO =
	C_RECTANGLE & -- Rectangle sourceRec
	C_INT &       -- int left
	C_INT &       -- int top
	C_INT &       -- int right
	C_INT &       -- int bottom
	C_INT         -- int type

--
-- Font character info
--
ifdef BITS64 then

public constant
	CharInfo_value      =  0, -- int
	CharInfo_rec        =  4, -- Rectangle
	CharInfo_offsetX    = 20, -- int
	CharInfo_offsetY    = 20, -- int
	CharInfo_advanceX   = 24, -- int
	CharInfo_data       = 28, -- unsigned char*
	SIZEOF_CHARINFO     = 36,
$

elsedef -- BITS32

public constant
	CharInfo_value      =  0, -- int
	CharInfo_rec        =  4, -- Rectangle
	CharInfo_offsetX    = 20, -- int
	CharInfo_offsetY    = 20, -- int
	CharInfo_advanceX   = 24, -- int
	CharInfo_data       = 28, -- unsigned char*
	SIZEOF_CHARINFO     = 32,
$

end ifdef

public enum
	CHARINFO_VALUE,
	CHARINFO_REC,
	CHARINFO_OFFSETX,
	CHARINFO_OFFSETY,
	CHARINFO_ADVANCEX,
	CHARINFO_DATA

constant C_CHARINFO =
	C_INT       & -- int value
	C_RECTANGLE & -- Rectangle rec
	C_INT &       -- int offsetX
	C_INT &       -- int offsetY
	C_INT &       -- int advanceX
	C_POINTER     -- unsigned char* data

--
-- Font type
--
ifdef BITS64 then

public constant
	Font_texture    =  0, -- Texture2D
	Font_baseSize   = 20, -- int
	Font_charsCount = 24, -- int
	Font_chars      = 28, -- CharInfo*
	SIZEOF_FONT     = 36,
$

elsedef -- BITS32

public constant
	Font_texture    =  0, -- Texture2D
	Font_baseSize   = 20, -- int
	Font_charsCount = 24, -- int
	Font_chars      = 28, -- CharInfo*
	SIZEOF_FONT     = 32,
$

end ifdef

public enum
	FONT_TEXTURE,
	FONT_BASESIZE,
	FONT_CHARSCOUNT,
	FONT_CHARS

constant C_FONT = 
	C_TEXTURE2D & -- Texture2D texture
	C_INT &       -- int baseSize
	C_INT &       -- int charsCount
	C_POINTER     -- CharInfo* chars

--
-- SpriteFont type
-- defaults to Font
--
public constant
	SpriteFont_texture      = Font_texture,
	SpriteFont_baseSize     = Font_baseSize,
	SpriteFont_charsCount   = Font_charsCount,
	SpriteFont_chars        = Font_chars,
	SIZEOF_SPRITEFONT       = SIZEOF_FONT,
$

public enum
	SPRITEFONT_TEXTURE,
	SPRITEFONT_BASESIZE,
	SPRITEFONT_CHARSCOUNT,
	SPRITEFONT_CHARS

constant C_SPRITEFONT = C_FONT

--
-- Camera type
--
public constant
	Camera_position =  0, -- Vector3
	Camera_target   = 12, -- Vector3
	Camera_up       = 24, -- Vector3
	Camera_fovy     = 36, -- float
	Camera_type     = 40, -- int
	SIZEOF_CAMERA   = 44,
$

public enum
	CAMERA_POSITION,
	CAMERA_TARGET,
	CAMERA_UP,
	CAMERA_FOVY,
	CAMERA_TYPE

constant C_CAMERA =
	C_VECTOR3 & -- Vector3 position
	C_VECTOR3 & -- Vector3 targer
	C_VECTOR3 & -- Vector3 up
	C_FLOAT   & -- float fovy
	C_INT       -- int type

constant C_STRING = C_POINTER


--atom raylibshim = open_dll( "raylib.dll" )

public constant
	shimLoadTexture             = define_c_proc( ray, "+shimLoadTexture", C_STRING & C_POINTER ),
	shimLoadTextureFromImage    = define_c_proc( ray, "+shimLoadTextureFromImage", C_IMAGE & C_POINTER ),
	shimGetMouseRay = define_c_proc(ray,"+shimGetMouseRay",C_VECTOR2 & C_CAMERA & C_POINTER),
	shimGetWorldToScreen = define_c_proc(ray,"+shimGetWorldToScreen", C_VECTOR3 & C_VECTOR2),
$

public function gLoadTexture( sequence filename )
	
	atom texture = allocate_data( SIZEOF_TEXTURE2D, TRUE )
	mem_set( texture, NULL, SIZEOF_TEXTURE2D )
	
	c_proc( shimLoadTexture, {allocate_string(filename,TRUE),texture} )
	
	atom id      = peek4u( texture + Texture2D_id )
	atom width   = peek4s( texture + Texture2D_width )
	atom height  = peek4s( texture + Texture2D_height )
	atom mipmaps = peek4s( texture + Texture2D_mipmaps )
	atom format  = peek4s( texture + Texture2D_format )
	
	return {id,width,height,mipmaps,format}
end function

public function gLoadTextureFromImage( sequence image )
	
	atom data    = image[IMAGE_DATA]
	atom width   = image[IMAGE_WIDTH]
	atom height  = image[IMAGE_HEIGHT]
	atom mipmaps = image[IMAGE_MIPMAPS]
	atom format  = image[IMAGE_FORMAT]
	
	atom texture = allocate_data( SIZEOF_TEXTURE2D, TRUE )
	mem_set( texture, NULL, SIZEOF_TEXTURE2D )
	
	c_proc( shimLoadTextureFromImage, {data,width,height,mipmaps,format,texture} )
	
	atom id = peek4u( texture + Texture2D_id )
	width   = peek4s( texture + Texture2D_width )
	height  = peek4s( texture + Texture2D_height )
	mipmaps = peek4s( texture + Texture2D_mipmaps )
	format  = peek4s( texture + Texture2D_format )
	
	return {id,width,height,mipmaps,format}
end function
4701.7